// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package config

import "gopkg.in/yaml.v3"

// Instance configuration
type InstanceConfig struct {
	// Using Tarantool as an application server, you can run your own Lua
	// applications. In the `app` section, you can load the application and provide an
	// application configuration in the `app.cfg` section.
	App *InstanceConfigApp `yaml:"app,omitempty"`

	// The `audit_log` section defines configuration parameters related to audit
	// logging.
	AuditLog *InstanceConfigAuditLog `yaml:"audit_log,omitempty"`

	// These options allow to redefine tarantool behavior in order to correspond to
	// the previous or the next major version.
	Compat *InstanceConfigCompat `yaml:"compat,omitempty"`

	// The `config` section defines various parameters related to centralized
	// configuration.
	Config *InstanceConfigConfig `yaml:"config,omitempty"`

	// Configure the administrative console. A client to the console is `tt connect`.
	Console *InstanceConfigConsole `yaml:"console,omitempty"`

	// The `credentials` section allows you to create users and grant them the
	// specified privileges.
	Credentials *InstanceConfigCredentials `yaml:"credentials,omitempty"`

	// The `database` section defines database-specific configuration parameters, such
	// as an instance's read-write mode or transaction isolation level.
	Database *InstanceConfigDatabase `yaml:"database,omitempty"`

	// The `failover` section defines parameters related to a supervised failover.
	Failover *InstanceConfigFailover `yaml:"failover,omitempty"`

	// The `feedback` section describes configuration parameters for sending
	// information about a running Tarantool instance to the specified feedback
	// server.
	Feedback *InstanceConfigFeedback `yaml:"feedback,omitempty"`

	// The `fiber` section describes options related to configuring fibers, yields,
	// and cooperative multitasking.
	Fiber *InstanceConfigFiber `yaml:"fiber,omitempty"`

	// The flightrec section describes options related to the flight recorder
	// configuration.
	Flightrec *InstanceConfigFlightrec `yaml:"flightrec,omitempty"`

	// The iproto section is used to configure parameters related to communicating to
	// and between cluster instances.
	Iproto *InstanceConfigIproto `yaml:"iproto,omitempty"`

	// Temporarily isolate an instance to perform replicaset repairing activities,
	// such as debugging a problem on the isolated instance without affecting the
	// non-isolated part or extracting data from the isolated instance to apply on the
	// non-isolated part of the replicaset.
	//
	// Effects of isolation:
	//
	// - The instance stops listening for new IProto connections.
	// - All current IProto connections are dropped.
	// - The instance switches to read-only mode.
	// - The instance disconnects from all replication upstreams.
	// - Other replicaset members exclude the isolated instance from their replication
	// upstreams.
	//
	// Note: the isolated instance can't be bootstrapped (a local snapshot is required
	// to start).
	Isolated bool `yaml:"isolated,omitempty"`

	// The `labels` section allows adding custom attributes to the instance. The keys
	// and values are strings.
	Labels InstanceConfigLabels `yaml:"labels,omitempty"`

	// The `log` section defines configuration parameters related to logging. To
	// handle logging in your application, use the log module.
	Log *InstanceConfigLog `yaml:"log,omitempty"`

	// This section defines configuration parameters related to Lua within Tarantool.
	Lua *InstanceConfigLua `yaml:"lua,omitempty"`

	// This section is used to configure parameters related to the memtx engine.
	Memtx *InstanceConfigMemtx `yaml:"memtx,omitempty"`

	// The `metrics` section provides the ability to collect and expose Tarantool
	// metrics (e.g. network, cpu, memtx and others).
	Metrics *InstanceConfigMetrics `yaml:"metrics,omitempty"`

	// The `process` section defines configuration parameters of the Tarantool process
	// in the system.
	Process *InstanceConfigProcess `yaml:"process,omitempty"`

	// This section defines configuration parameters related to replication.
	Replication *InstanceConfigReplication `yaml:"replication,omitempty"`

	// Specify the roles of an instance. To specify a role's configuration, use the
	// roles_cfg option.
	Roles []string `yaml:"roles,omitempty"`

	// Specify a role's configuration. This option accepts a role name as the key and
	// a role's configuration as the value. To specify the roles of an instance, use
	// the roles option.
	RolesCfg InstanceConfigRolesCfg `yaml:"roles_cfg,omitempty"`

	// This section defines configuration parameters related to various security
	// settings.
	Security *InstanceConfigSecurity `yaml:"security,omitempty"`

	// This section defines configuration parameters related to sharding.
	Sharding *InstanceConfigSharding `yaml:"sharding,omitempty"`

	// This section defines configuration parameters related to the snapshot files.
	Snapshot *InstanceConfigSnapshot `yaml:"snapshot,omitempty"`

	// This section defines configuration parameters related to SQL.
	Sql *InstanceConfigSql `yaml:"sql,omitempty"`

	// This section defines configuration parameters related to the vinyl storage
	// engine.
	Vinyl *InstanceConfigVinyl `yaml:"vinyl,omitempty"`

	// This section defines configuration parameters related to write-ahead log.
	Wal *InstanceConfigWal `yaml:"wal,omitempty"`
}

// Using Tarantool as an application server, you can run your own Lua applications.
// In the `app` section, you can load the application and provide an application
// configuration in the `app.cfg` section.
type InstanceConfigApp struct {
	// A configuration of the application loaded using `app.file` or `app.module`.
	Cfg InstanceConfigAppCfg `yaml:"cfg,omitempty"`

	// A path to a Lua file to load an application from.
	File *string `yaml:"file,omitempty"`

	// A Lua module to load an application from.
	Module *string `yaml:"module,omitempty"`
}

// A configuration of the application loaded using `app.file` or `app.module`.
type InstanceConfigAppCfg map[string]interface{}

// The `audit_log` section defines configuration parameters related to audit
// logging.
type InstanceConfigAuditLog struct {
	// If set to `true`, the audit subsystem extracts and prints only the primary key
	// instead of full tuples in DML events (`space_insert`, `space_replace`,
	// `space_delete`). Otherwise, full tuples are logged. The option may be useful in
	// case tuples are big.
	ExtractKey bool `yaml:"extract_key,omitempty"`

	// Specify a file for the audit log destination. You can set the `file` type using
	// the audit_log.to option. If you write logs to a file, Tarantool reopens the
	// audit log at SIGHUP.
	File string `yaml:"file,omitempty"`

	// Enable logging for a specified subset of audit events.
	Filter []InstanceConfigAuditLogFilterElem `yaml:"filter,omitempty"`

	// Specify a format that is used for the audit log.
	Format InstanceConfigAuditLogFormat `yaml:"format,omitempty"`

	// Specify the logging behavior if the system is not ready to write. If set to
	// `true`, Tarantool does not block during logging if the system is non-writable
	// and writes a message instead. Using this value may improve logging performance
	// at the cost of losing some log messages.
	Nonblock bool `yaml:"nonblock,omitempty"`

	// Start a program and write logs to its standard input (`stdin`). To send logs to
	// a program's standard input, you need to set `audit_log.to` to `pipe`.
	Pipe *string `yaml:"pipe,omitempty"`

	// The array of space names for which data operation events (`space_select`,
	// `space_insert`, `space_replace`, `space_delete`) should be logged. The array
	// accepts string values. If set to box.NULL, the data operation events are logged
	// for all spaces.
	Spaces []string `yaml:"spaces,omitempty"`

	// This module allows configuring the system logger (syslog) for audit logs in
	// Tarantool. It provides options for specifying the syslog server, facility, and
	// identity for logging messages.
	Syslog *InstanceConfigAuditLogSyslog `yaml:"syslog,omitempty"`

	// Enable audit logging and define the log location.
	To InstanceConfigAuditLogTo `yaml:"to,omitempty"`
}

type InstanceConfigAuditLogFilterElem string

const InstanceConfigAuditLogFilterElemAccessDenied InstanceConfigAuditLogFilterElem = "access_denied"
const InstanceConfigAuditLogFilterElemAll InstanceConfigAuditLogFilterElem = "all"
const InstanceConfigAuditLogFilterElemAudit InstanceConfigAuditLogFilterElem = "audit"
const InstanceConfigAuditLogFilterElemAuditEnable InstanceConfigAuditLogFilterElem = "audit_enable"
const InstanceConfigAuditLogFilterElemAuth InstanceConfigAuditLogFilterElem = "auth"
const InstanceConfigAuditLogFilterElemAuthFail InstanceConfigAuditLogFilterElem = "auth_fail"
const InstanceConfigAuditLogFilterElemAuthOk InstanceConfigAuditLogFilterElem = "auth_ok"
const InstanceConfigAuditLogFilterElemCall InstanceConfigAuditLogFilterElem = "call"
const InstanceConfigAuditLogFilterElemCompatibility InstanceConfigAuditLogFilterElem = "compatibility"
const InstanceConfigAuditLogFilterElemCustom InstanceConfigAuditLogFilterElem = "custom"
const InstanceConfigAuditLogFilterElemDataOperations InstanceConfigAuditLogFilterElem = "data_operations"
const InstanceConfigAuditLogFilterElemDdl InstanceConfigAuditLogFilterElem = "ddl"
const InstanceConfigAuditLogFilterElemDisconnect InstanceConfigAuditLogFilterElem = "disconnect"
const InstanceConfigAuditLogFilterElemDml InstanceConfigAuditLogFilterElem = "dml"
const InstanceConfigAuditLogFilterElemEval InstanceConfigAuditLogFilterElem = "eval"
const InstanceConfigAuditLogFilterElemNone InstanceConfigAuditLogFilterElem = "none"
const InstanceConfigAuditLogFilterElemPasswordChange InstanceConfigAuditLogFilterElem = "password_change"
const InstanceConfigAuditLogFilterElemPriv InstanceConfigAuditLogFilterElem = "priv"
const InstanceConfigAuditLogFilterElemRoleCreate InstanceConfigAuditLogFilterElem = "role_create"
const InstanceConfigAuditLogFilterElemRoleDrop InstanceConfigAuditLogFilterElem = "role_drop"
const InstanceConfigAuditLogFilterElemRoleGrantRights InstanceConfigAuditLogFilterElem = "role_grant_rights"
const InstanceConfigAuditLogFilterElemRoleRevokeRights InstanceConfigAuditLogFilterElem = "role_revoke_rights"
const InstanceConfigAuditLogFilterElemSpaceAlter InstanceConfigAuditLogFilterElem = "space_alter"
const InstanceConfigAuditLogFilterElemSpaceCreate InstanceConfigAuditLogFilterElem = "space_create"
const InstanceConfigAuditLogFilterElemSpaceDelete InstanceConfigAuditLogFilterElem = "space_delete"
const InstanceConfigAuditLogFilterElemSpaceDrop InstanceConfigAuditLogFilterElem = "space_drop"
const InstanceConfigAuditLogFilterElemSpaceInsert InstanceConfigAuditLogFilterElem = "space_insert"
const InstanceConfigAuditLogFilterElemSpaceReplace InstanceConfigAuditLogFilterElem = "space_replace"
const InstanceConfigAuditLogFilterElemSpaceSelect InstanceConfigAuditLogFilterElem = "space_select"
const InstanceConfigAuditLogFilterElemUserCreate InstanceConfigAuditLogFilterElem = "user_create"
const InstanceConfigAuditLogFilterElemUserDisable InstanceConfigAuditLogFilterElem = "user_disable"
const InstanceConfigAuditLogFilterElemUserDrop InstanceConfigAuditLogFilterElem = "user_drop"
const InstanceConfigAuditLogFilterElemUserEnable InstanceConfigAuditLogFilterElem = "user_enable"
const InstanceConfigAuditLogFilterElemUserGrantRights InstanceConfigAuditLogFilterElem = "user_grant_rights"
const InstanceConfigAuditLogFilterElemUserRevokeRights InstanceConfigAuditLogFilterElem = "user_revoke_rights"

type InstanceConfigAuditLogFormat string

const InstanceConfigAuditLogFormatCsv InstanceConfigAuditLogFormat = "csv"
const InstanceConfigAuditLogFormatJson InstanceConfigAuditLogFormat = "json"
const InstanceConfigAuditLogFormatPlain InstanceConfigAuditLogFormat = "plain"

// This module allows configuring the system logger (syslog) for audit logs in
// Tarantool. It provides options for specifying the syslog server, facility, and
// identity for logging messages.
type InstanceConfigAuditLogSyslog struct {
	// Define the syslog facility, which indicates the type of application generating
	// the log entries (e.g. kernel, user-level, or system daemon). To enable syslog
	// logging, set `audit_log.to` to `syslog`.
	Facility string `yaml:"facility,omitempty"`

	// Specify an application name to show in logs. You can enable logging to a system
	// logger using the `audit_log.to` option.
	Identity string `yaml:"identity,omitempty"`

	// Set a location for the syslog server. It can be a Unix socket path starting
	// with "unix:" or an ipv4 port number. You can enable logging to a system logger
	// using the `audit_log.to` option.
	Server *string `yaml:"server,omitempty"`
}

type InstanceConfigAuditLogTo string

const InstanceConfigAuditLogToDevnull InstanceConfigAuditLogTo = "devnull"
const InstanceConfigAuditLogToFile InstanceConfigAuditLogTo = "file"
const InstanceConfigAuditLogToPipe InstanceConfigAuditLogTo = "pipe"
const InstanceConfigAuditLogToSyslog InstanceConfigAuditLogTo = "syslog"

// These options allow to redefine tarantool behavior in order to correspond to the
// previous or the next major version.
type InstanceConfigCompat struct {
	// Define how to store binary data fields in Lua after decoding:
	//
	// - `new` (3.x default): as varbinary object
	// - `old` (2.x default): as plain strings
	BinaryDataDecoding InstanceConfigCompatBinaryDataDecoding `yaml:"binary_data_decoding,omitempty"`

	// Set a default replication sync timeout:
	//
	// - `new` (3.x default): 0
	// - `old` (2.x default): 300 seconds
	BoxCfgReplicationSyncTimeout InstanceConfigCompatBoxCfgReplicationSyncTimeout `yaml:"box_cfg_replication_sync_timeout,omitempty"`

	// Whether to consider most system spaces as synchronized regardless of the
	// `is_sync` space option:
	//
	// - `new` (4.x default): System spaces are synchronized when the synchronous
	// queue is claimed (`box.info.synchro.queue.owner ~= 0`), except for
	// `vinyl_defer_delete` (local space) and `sequence_data` (synchronized by
	// synchronous user spaces operations)
	// - `old` (3.x default): System spaces are not synchronized unless explicitly
	// marked with the `is_sync` option
	BoxConsiderSystemSpacesSynchronous InstanceConfigCompatBoxConsiderSystemSpacesSynchronous `yaml:"box_consider_system_spaces_synchronous,omitempty"`

	// Set the verbosity of error objects serialization:
	//
	// - `new` (4.x default): serialize the error message together with other
	// potentially useful fields
	// - `old` (3.x default): serialize only the error message
	BoxErrorSerializeVerbose InstanceConfigCompatBoxErrorSerializeVerbose `yaml:"box_error_serialize_verbose,omitempty"`

	// Whether to show all the error fields in `box.error.unpack()`:
	//
	// - `new` (4.x default): do not show `base_type` and `custom_type` fields; do not
	// show the `code` field if it is 0. Note that `base_type` is still accessible for
	// an error object
	// - `old` (3.x default): show all fields
	BoxErrorUnpackTypeAndCode InstanceConfigCompatBoxErrorUnpackTypeAndCode `yaml:"box_error_unpack_type_and_code,omitempty"`

	// Define the behavior of `box.info.cluster`:
	//
	// - `new` (3.x default): `box.info.cluster` shows info about the entire cluster,
	// `box.info.replicaset` shows info about the replica set
	// - `old` (2.x default): `box.info.cluster` shows info about the replica set
	BoxInfoClusterMeaning InstanceConfigCompatBoxInfoClusterMeaning `yaml:"box_info_cluster_meaning,omitempty"`

	// Whether to raise errors on attempts to call the deprecated function
	// `box.session.push`:
	//
	// - `new` (4.x default): raise an error
	// - `old` (3.x default): do not raise an error
	BoxSessionPushDeprecation InstanceConfigCompatBoxSessionPushDeprecation `yaml:"box_session_push_deprecation,omitempty"`

	// Whether the `execute` privilege can be granted on spaces:
	//
	// - `new` (3.x default): an error is raised
	// - `old` (2.x default): the privilege can be granted with no actual effect
	BoxSpaceExecutePriv InstanceConfigCompatBoxSpaceExecutePriv `yaml:"box_space_execute_priv,omitempty"`

	// Set the maximum space identifier (`box.schema.SPACE_MAX`):
	//
	// - `new` (3.x default): 2147483646
	// - `old` (2.x default): 2147483647
	BoxSpaceMax InstanceConfigCompatBoxSpaceMax `yaml:"box_space_max,omitempty"`

	// Controls `IPROTO_FEATURE_CALL_RET_TUPLE_EXTENSION` and
	// `IPROTO_FEATURE_CALL_ARG_TUPLE_EXTENSION` feature bits that define tuple
	// encoding in iproto call and eval requests.
	//
	// - `new` (3.x default): tuples with formats are encoded as `MP_TUPLE`
	// - `old` (2.x default): tuples with formats are encoded as `MP_ARRAY`
	BoxTupleExtension InstanceConfigCompatBoxTupleExtension `yaml:"box_tuple_extension,omitempty"`

	// Controls how `box.tuple.new` interprets an argument list:
	//
	// - `new` (3.x default): as a value with a tuple format
	// - `old` (2.x default): as an array of tuple fields
	BoxTupleNewVararg InstanceConfigCompatBoxTupleNewVararg `yaml:"box_tuple_new_vararg,omitempty"`

	// Controls wrapping of multiple results of a stored C function when returning
	// them via iproto:
	//
	// - `new` (3.x default): return without wrapping (consistently with a local call
	// via `box.func`)
	// - `old` (2.x default): wrap results into a MessagePack array
	CFuncIprotoMultireturn InstanceConfigCompatCFuncIprotoMultireturn `yaml:"c_func_iproto_multireturn,omitempty"`

	// Whether a console session has its own variable scope:
	//
	// - `new` (4.x default): non-local variable assignments are written to a variable
	// scope attached to the console session
	// - `old` (3.x default): all non-local variable assignments from the console are
	// written to globals
	ConsoleSessionScopeVars InstanceConfigCompatConsoleSessionScopeVars `yaml:"console_session_scope_vars,omitempty"`

	// Define the behavior of fiber channels after closing:
	//
	// - `new` (3.x default): mark the channel read-only
	// - `old` (2.x default): destroy the channel object
	FiberChannelCloseMode InstanceConfigCompatFiberChannelCloseMode `yaml:"fiber_channel_close_mode,omitempty"`

	// Define the maximum fiber execution time without a yield:
	//
	// - `new` (3.x default): `{warn = 0.5, err = 1.0}`
	// - `old` (2.x default): infinity (no warnings or errors raised)
	FiberSliceDefault InstanceConfigCompatFiberSliceDefault `yaml:"fiber_slice_default,omitempty"`

	// Whether to escape the forward slash symbol "/" using a backslash in a
	// `json.encode()` result:
	//
	// - `new` (3.x default): do not escape the forward slash
	// - `old` (2.x default): escape the forward slash
	JsonEscapeForwardSlash InstanceConfigCompatJsonEscapeForwardSlash `yaml:"json_escape_forward_slash,omitempty"`

	// The `compat.replication_synchro_timeout` option controls transaction rollback
	// due to `replication.synchro_timeout`.
	//
	// - `new` (4.x default): A synchronous transaction can remain in the synchro
	// queue indefinitely until it reaches a quorum of confirmations.
	// `replication.synchro_timeout` is used only to wait confirmation in
	// promote/demote and gc-checkpointing. If some transaction in limbo did not have
	// time to commit within `replication_synchro_timeout`, the corresponding
	// operation: promote/demote or gc-checkpointing can be aborted automatically
	// - `old` (3.x default): unconfirmed synchronous transactions are rolled back
	// after a `replication.synchro_timeout`
	ReplicationSynchroTimeout InstanceConfigCompatReplicationSynchroTimeout `yaml:"replication_synchro_timeout,omitempty"`

	// Whether to enable access checks for SQL requests over iproto:
	//
	// - `new` (3.x default): check the user's access permissions
	// - `old` (2.x default): allow any user to execute SQL over iproto
	SqlPriv InstanceConfigCompatSqlPriv `yaml:"sql_priv,omitempty"`

	// Controls the default value of the `sql_seq_scan` session setting:
	//
	// - `new` (3.x default): false
	// - `old` (2.x default): true
	SqlSeqScanDefault InstanceConfigCompatSqlSeqScanDefault `yaml:"sql_seq_scan_default,omitempty"`

	// Whether to use the option 'wal_cleanup_delay':
	//
	// - `new` (4.x default): raise an error
	// - `old` (3.x default): log a deprecation warning
	WalCleanupDelayDeprecation InstanceConfigCompatWalCleanupDelayDeprecation `yaml:"wal_cleanup_delay_deprecation,omitempty"`

	// Whether to encode in block scalar style all multiline strings or ones
	// containing the `\n\n` substring:
	//
	// - `new` (3.x default): all multiline strings
	// - `old` (2.x default): only strings containing the `\n\n` substring
	YamlPrettyMultiline InstanceConfigCompatYamlPrettyMultiline `yaml:"yaml_pretty_multiline,omitempty"`
}

type InstanceConfigCompatBinaryDataDecoding string

const InstanceConfigCompatBinaryDataDecodingNew InstanceConfigCompatBinaryDataDecoding = "new"
const InstanceConfigCompatBinaryDataDecodingOld InstanceConfigCompatBinaryDataDecoding = "old"

type InstanceConfigCompatBoxCfgReplicationSyncTimeout string

const InstanceConfigCompatBoxCfgReplicationSyncTimeoutNew InstanceConfigCompatBoxCfgReplicationSyncTimeout = "new"
const InstanceConfigCompatBoxCfgReplicationSyncTimeoutOld InstanceConfigCompatBoxCfgReplicationSyncTimeout = "old"

type InstanceConfigCompatBoxConsiderSystemSpacesSynchronous string

const InstanceConfigCompatBoxConsiderSystemSpacesSynchronousNew InstanceConfigCompatBoxConsiderSystemSpacesSynchronous = "new"
const InstanceConfigCompatBoxConsiderSystemSpacesSynchronousOld InstanceConfigCompatBoxConsiderSystemSpacesSynchronous = "old"

type InstanceConfigCompatBoxErrorSerializeVerbose string

const InstanceConfigCompatBoxErrorSerializeVerboseNew InstanceConfigCompatBoxErrorSerializeVerbose = "new"
const InstanceConfigCompatBoxErrorSerializeVerboseOld InstanceConfigCompatBoxErrorSerializeVerbose = "old"

type InstanceConfigCompatBoxErrorUnpackTypeAndCode string

const InstanceConfigCompatBoxErrorUnpackTypeAndCodeNew InstanceConfigCompatBoxErrorUnpackTypeAndCode = "new"
const InstanceConfigCompatBoxErrorUnpackTypeAndCodeOld InstanceConfigCompatBoxErrorUnpackTypeAndCode = "old"

type InstanceConfigCompatBoxInfoClusterMeaning string

const InstanceConfigCompatBoxInfoClusterMeaningNew InstanceConfigCompatBoxInfoClusterMeaning = "new"
const InstanceConfigCompatBoxInfoClusterMeaningOld InstanceConfigCompatBoxInfoClusterMeaning = "old"

type InstanceConfigCompatBoxSessionPushDeprecation string

const InstanceConfigCompatBoxSessionPushDeprecationNew InstanceConfigCompatBoxSessionPushDeprecation = "new"
const InstanceConfigCompatBoxSessionPushDeprecationOld InstanceConfigCompatBoxSessionPushDeprecation = "old"

type InstanceConfigCompatBoxSpaceExecutePriv string

const InstanceConfigCompatBoxSpaceExecutePrivNew InstanceConfigCompatBoxSpaceExecutePriv = "new"
const InstanceConfigCompatBoxSpaceExecutePrivOld InstanceConfigCompatBoxSpaceExecutePriv = "old"

type InstanceConfigCompatBoxSpaceMax string

const InstanceConfigCompatBoxSpaceMaxNew InstanceConfigCompatBoxSpaceMax = "new"
const InstanceConfigCompatBoxSpaceMaxOld InstanceConfigCompatBoxSpaceMax = "old"

type InstanceConfigCompatBoxTupleExtension string

const InstanceConfigCompatBoxTupleExtensionNew InstanceConfigCompatBoxTupleExtension = "new"
const InstanceConfigCompatBoxTupleExtensionOld InstanceConfigCompatBoxTupleExtension = "old"

type InstanceConfigCompatBoxTupleNewVararg string

const InstanceConfigCompatBoxTupleNewVarargNew InstanceConfigCompatBoxTupleNewVararg = "new"
const InstanceConfigCompatBoxTupleNewVarargOld InstanceConfigCompatBoxTupleNewVararg = "old"

type InstanceConfigCompatCFuncIprotoMultireturn string

const InstanceConfigCompatCFuncIprotoMultireturnNew InstanceConfigCompatCFuncIprotoMultireturn = "new"
const InstanceConfigCompatCFuncIprotoMultireturnOld InstanceConfigCompatCFuncIprotoMultireturn = "old"

type InstanceConfigCompatConsoleSessionScopeVars string

const InstanceConfigCompatConsoleSessionScopeVarsNew InstanceConfigCompatConsoleSessionScopeVars = "new"
const InstanceConfigCompatConsoleSessionScopeVarsOld InstanceConfigCompatConsoleSessionScopeVars = "old"

type InstanceConfigCompatFiberChannelCloseMode string

const InstanceConfigCompatFiberChannelCloseModeNew InstanceConfigCompatFiberChannelCloseMode = "new"
const InstanceConfigCompatFiberChannelCloseModeOld InstanceConfigCompatFiberChannelCloseMode = "old"

type InstanceConfigCompatFiberSliceDefault string

const InstanceConfigCompatFiberSliceDefaultNew InstanceConfigCompatFiberSliceDefault = "new"
const InstanceConfigCompatFiberSliceDefaultOld InstanceConfigCompatFiberSliceDefault = "old"

type InstanceConfigCompatJsonEscapeForwardSlash string

const InstanceConfigCompatJsonEscapeForwardSlashNew InstanceConfigCompatJsonEscapeForwardSlash = "new"
const InstanceConfigCompatJsonEscapeForwardSlashOld InstanceConfigCompatJsonEscapeForwardSlash = "old"

type InstanceConfigCompatReplicationSynchroTimeout string

const InstanceConfigCompatReplicationSynchroTimeoutNew InstanceConfigCompatReplicationSynchroTimeout = "new"
const InstanceConfigCompatReplicationSynchroTimeoutOld InstanceConfigCompatReplicationSynchroTimeout = "old"

type InstanceConfigCompatSqlPriv string

const InstanceConfigCompatSqlPrivNew InstanceConfigCompatSqlPriv = "new"
const InstanceConfigCompatSqlPrivOld InstanceConfigCompatSqlPriv = "old"

type InstanceConfigCompatSqlSeqScanDefault string

const InstanceConfigCompatSqlSeqScanDefaultNew InstanceConfigCompatSqlSeqScanDefault = "new"
const InstanceConfigCompatSqlSeqScanDefaultOld InstanceConfigCompatSqlSeqScanDefault = "old"

type InstanceConfigCompatWalCleanupDelayDeprecation string

const InstanceConfigCompatWalCleanupDelayDeprecationNew InstanceConfigCompatWalCleanupDelayDeprecation = "new"
const InstanceConfigCompatWalCleanupDelayDeprecationOld InstanceConfigCompatWalCleanupDelayDeprecation = "old"

type InstanceConfigCompatYamlPrettyMultiline string

const InstanceConfigCompatYamlPrettyMultilineNew InstanceConfigCompatYamlPrettyMultiline = "new"
const InstanceConfigCompatYamlPrettyMultilineOld InstanceConfigCompatYamlPrettyMultiline = "old"

// The `config` section defines various parameters related to centralized
// configuration.
type InstanceConfigConfig struct {
	// Defines custom variables in the cluster configuration by loading values from an
	// environment variable or a file.
	Context InstanceConfigConfigContext `yaml:"context,omitempty"`

	// This section describes options related to providing connection settings to a
	// centralized etcd-based storage. If `replication.failover` is set to
	// `supervised`, Tarantool also uses etcd to maintain the state of failover
	// coordinators.
	Etcd *InstanceConfigConfigEtcd `yaml:"etcd,omitempty"`

	// Specify how the configuration is reloaded. This option accepts the following
	// values:
	//
	// - `auto`: configuration is reloaded automatically when it is changed.
	// - `manual`: configuration should be reloaded manually. In this case, you can
	// reload the configuration in the application code using `config:reload()`.
	Reload InstanceConfigConfigReload `yaml:"reload,omitempty"`

	// This section describes options related to providing connection settings to a
	// centralized Tarantool-based storage.
	Storage *InstanceConfigConfigStorage `yaml:"storage,omitempty"`
}

// Defines custom variables in the cluster configuration by loading values from an
// environment variable or a file.
type InstanceConfigConfigContext map[string]struct {
	// The name of an environment variable to load a context variable from. To load a
	// context variable from an environment variable, set `config.context.<name>.from`
	// to `env`.
	Env *string `yaml:"env,omitempty"`

	// The path to a file to load a context variable from. To load a configuration
	// value from a file, set `config.context.<name>.from` to `file`.
	File *string `yaml:"file,omitempty"`

	// The type of storage to load a context variable from. There are the following
	// storage types:
	//
	// - `file`: load a context variable from a file. In this case, you need to
	// specify the path to the file using `config.context.<name>.file`
	// - `env`: load a context variable from an environment variable. In this case,
	// specify the environment variable name using `config.context.<name>.env`
	From *InstanceConfigConfigContextValueFrom `yaml:"from,omitempty"`

	// (Optional) Whether to strip whitespace characters and newlines from the end of
	// data.
	Rstrip *bool `yaml:"rstrip,omitempty"`
}

type InstanceConfigConfigContextValueFrom string

const InstanceConfigConfigContextValueFromEnv InstanceConfigConfigContextValueFrom = "env"
const InstanceConfigConfigContextValueFromFile InstanceConfigConfigContextValueFrom = "file"

// This section describes options related to providing connection settings to a
// centralized etcd-based storage. If `replication.failover` is set to
// `supervised`, Tarantool also uses etcd to maintain the state of failover
// coordinators.
type InstanceConfigConfigEtcd struct {
	// The list of endpoints used to access an etcd cluster.
	Endpoints []string `yaml:"endpoints,omitempty"`

	// HTTP client options for the etcd-client, used to fetch and subscribe to the
	// cluster configuration stored in etcd.
	Http *InstanceConfigConfigEtcdHttp `yaml:"http,omitempty"`

	// A password used for authentication.
	Password *string `yaml:"password,omitempty"`

	// A key prefix used to search a configuration on an etcd server. Tarantool
	// searches keys by the following path: `<prefix>/config/*`. Note that `<prefix>`
	// should start with a slash (`/`).
	Prefix *string `yaml:"prefix,omitempty"`

	// TLS options.
	Ssl *InstanceConfigConfigEtcdSsl `yaml:"ssl,omitempty"`

	// A username used for authentication.
	Username *string `yaml:"username,omitempty"`

	// Options for watcher requests: watchcreate, watchwait and watchcancel.
	Watchers *InstanceConfigConfigEtcdWatchers `yaml:"watchers,omitempty"`
}

// HTTP client options for the etcd-client, used to fetch and subscribe to the
// cluster configuration stored in etcd.
type InstanceConfigConfigEtcdHttp struct {
	// HTTP client request options.
	Request *InstanceConfigConfigEtcdHttpRequest `yaml:"request,omitempty"`
}

// HTTP client request options.
type InstanceConfigConfigEtcdHttpRequest struct {
	// A time period required to process an HTTP request to an etcd server: from
	// sending a request to receiving a response.
	Timeout *float64 `yaml:"timeout,omitempty"`

	// A Unix domain socket used to connect to an etcd server.
	UnixSocket *string `yaml:"unix_socket,omitempty"`
}

// TLS options.
type InstanceConfigConfigEtcdSsl struct {
	// A path to a trusted certificate authorities (CA) file.
	CaFile *string `yaml:"ca_file,omitempty"`

	// A path to a directory holding certificates to verify the peer with.
	CaPath *string `yaml:"ca_path,omitempty"`

	// A path to an SSL certificate file.
	SslCert *string `yaml:"ssl_cert,omitempty"`

	// A path to a private SSL key file.
	SslKey *string `yaml:"ssl_key,omitempty"`

	// Enable verification of the certificate's name (CN) against the specified host.
	VerifyHost *bool `yaml:"verify_host,omitempty"`

	// Enable verification of the peer's SSL certificate.
	VerifyPeer *bool `yaml:"verify_peer,omitempty"`
}

// Options for watcher requests: watchcreate, watchwait and watchcancel.
type InstanceConfigConfigEtcdWatchers struct {
	// The maximum number of attempts to reconnect to an etcd server in case of
	// connection failure.
	ReconnectMaxAttempts *int `yaml:"reconnect_max_attempts,omitempty"`

	// The timeout (in seconds) between attempts to reconnect to an etcd server in
	// case of connection failure.
	ReconnectTimeout *float64 `yaml:"reconnect_timeout,omitempty"`
}

type InstanceConfigConfigReload string

const InstanceConfigConfigReloadAuto InstanceConfigConfigReload = "auto"
const InstanceConfigConfigReloadManual InstanceConfigConfigReload = "manual"

// This section describes options related to providing connection settings to a
// centralized Tarantool-based storage.
type InstanceConfigConfigStorage struct {
	// An array of endpoints used to access a configuration storage. Each endpoint can
	// include the following fields:
	//
	// - `uri`: a URI of the configuration storage's instance.
	// - `login`: a username used to connect to the instance.
	// - `password`: a password used for authentication.
	// - `params`: SSL parameters required for encrypted connections
	Endpoints []InstanceConfigConfigStorageEndpointsElem `yaml:"endpoints,omitempty"`

	// A key prefix used to search a configuration in a centralized configuration
	// storage. Tarantool searches keys by the following path: `<prefix>/config/*`.
	// Note that `<prefix>` should start with a slash (`/`).
	Prefix *string `yaml:"prefix,omitempty"`

	// A number of seconds to wait before reconnecting to a configuration storage.
	ReconnectAfter float64 `yaml:"reconnect_after,omitempty"`

	// The interval (in seconds) to perform the status check of a configuration
	// storage.
	Timeout float64 `yaml:"timeout,omitempty"`
}

// Element that represents a configuration storage endpoint with the following
// fields:
//
// - `uri`: a URI of the configuration storage's instance.
// - `login`: a username used to connect to the instance.
// - `password`: a password used for authentication.
// - `params`: SSL parameters required for encrypted connections.
type InstanceConfigConfigStorageEndpointsElem struct {
	// A username used to connect to the instance.
	Login *string `yaml:"login,omitempty"`

	// SSL parameters required for encrypted connections.
	Params *InstanceConfigConfigStorageEndpointsElemParams `yaml:"params,omitempty"`

	// A password used for authentication.
	Password *string `yaml:"password,omitempty"`

	// A URI of the configuration storage's instance.
	Uri *string `yaml:"uri,omitempty"`
}

// SSL parameters required for encrypted connections.
type InstanceConfigConfigStorageEndpointsElemParams struct {
	// (Optional) A path to a trusted certificate authorities (CA) file. If not set,
	// the peer won't be checked for authenticity.
	//
	// Both a server and a client can use the ssl_ca_file parameter:
	//
	// - If it's on the server side, the server verifies the client.
	// - If it's on the client side, the client verifies the server.
	// - If both sides have the CA files, the server and the client verify each other.
	SslCaFile *string `yaml:"ssl_ca_file,omitempty"`

	// A path to an SSL certificate file:
	//
	// - For a server, it's mandatory.
	// - For a client, it's mandatory if the ssl_ca_file parameter is set for a
	// server; otherwise, optional.
	SslCertFile *string `yaml:"ssl_cert_file,omitempty"`

	// (Optional) A colon-separated (:) list of SSL cipher suites the connection can
	// use. Note that the list is not validated: if a cipher suite is unknown,
	// Tarantool ignores it, doesn't establish the connection, and writes to the log
	// that no shared cipher was found.
	SslCiphers *string `yaml:"ssl_ciphers,omitempty"`

	// A path to a private SSL key file:
	//
	// - For a server, it's mandatory.
	// - For a client, it's mandatory if the `ssl_ca_file` parameter is set for a
	// server; otherwise, optional.
	//
	// If the private key is encrypted, provide a password for it in the
	// `ssl_password` or `ssl_password_file` parameter
	SslKeyFile *string `yaml:"ssl_key_file,omitempty"`

	// (Optional) A password for an encrypted private SSL key provided using
	// `ssl_key_file`. Alternatively, the password can be provided in
	// `ssl_password_file`.
	//
	// Tarantool applies the `ssl_password` and `ssl_password_file` parameters in the
	// following order:
	//
	// - If `ssl_password` is provided, Tarantool tries to decrypt the private key
	// with it.
	// - If `ssl_password` is incorrect or isn't provided, Tarantool tries all
	// passwords from `ssl_password_file` one by one in the order they are written.
	// - If `ssl_password` and all passwords from `ssl_password_file` are incorrect,
	// or none of them is provided, Tarantool treats the private key as unencrypted.
	SslPassword *string `yaml:"ssl_password,omitempty"`

	// (Optional) A text file with one or more passwords for encrypted private SSL
	// keys provided using `ssl_key_file` (each on a separate line). Alternatively,
	// the password can be provided in `ssl_password`.
	SslPasswordFile *string `yaml:"ssl_password_file,omitempty"`

	// Allows you to enable traffic encryption for client-server communications over
	// binary connections. In a Tarantool cluster, one instance might act as the
	// server that accepts connections from other instances and the client that
	// connects to other instances.
	//
	// `<uri>.params.transport` accepts one of the following values:
	//
	// - `plain` (default): turn off traffic encryption,
	// - `ssl`: encrypt traffic by using the TLS 1.2 protocol (EE only).
	Transport *InstanceConfigConfigStorageEndpointsElemParamsTransport `yaml:"transport,omitempty"`
}

type InstanceConfigConfigStorageEndpointsElemParamsTransport string

const InstanceConfigConfigStorageEndpointsElemParamsTransportPlain InstanceConfigConfigStorageEndpointsElemParamsTransport = "plain"
const InstanceConfigConfigStorageEndpointsElemParamsTransportSsl InstanceConfigConfigStorageEndpointsElemParamsTransport = "ssl"

// Configure the administrative console. A client to the console is `tt connect`.
type InstanceConfigConsole struct {
	// Whether to listen on the Unix socket provided in the console.socket option.
	//
	// If the option is set to `false`, the administrative console is disabled.
	Enabled bool `yaml:"enabled,omitempty"`

	// The Unix socket for the administrative console.
	//
	// Mind the following nuances:
	//
	// - Only a Unix domain socket is allowed. A TCP socket can't be configured this
	// way.
	// - `console.socket` is a file path, without any `unix:` or `unix/:` prefixes.
	// - If the file path is a relative path, it is interpreted relative to
	// `process.work_dir`.
	Socket string `yaml:"socket,omitempty"`
}

// The `credentials` section allows you to create users and grant them the
// specified privileges.
type InstanceConfigCredentials struct {
	// An array of roles that can be granted to users or other roles.
	Roles InstanceConfigCredentialsRoles `yaml:"roles,omitempty"`

	// An array of users.
	Users InstanceConfigCredentialsUsers `yaml:"users,omitempty"`
}

// An array of roles that can be granted to users or other roles.
type InstanceConfigCredentialsRoles map[string]struct {
	// An array of privileges granted to this role.
	Privileges []InstanceConfigCredentialsRolesValuePrivilegesElem `yaml:"privileges,omitempty"`

	// An array of roles granted to this role.
	Roles []string `yaml:"roles,omitempty"`
}

// Privileges that can be granted to a user with this role.
type InstanceConfigCredentialsRolesValuePrivilegesElem struct {
	// Registered functions to which user with this role gets the specified
	// permissions.
	Functions []string `yaml:"functions,omitempty"`

	// Defines the Lua functions that the user with this role has permission to call.
	// This field accepts a special value, `all`, which grants the privilege to use
	// any global non-built-in Lua functions.
	LuaCall []string `yaml:"lua_call,omitempty"`

	// Whether this user with this role can execute arbitrary Lua code.
	LuaEval *bool `yaml:"lua_eval,omitempty"`

	// Permissions assigned to user with this role.
	Permissions []InstanceConfigCredentialsRolesValuePrivilegesElemPermissionsElem `yaml:"permissions,omitempty"`

	// Sequences to which user with this role gets the specified permissions.
	Sequences []string `yaml:"sequences,omitempty"`

	// Spaces to which user with this role gets the specified permissions.
	Spaces []string `yaml:"spaces,omitempty"`

	// Whether user with this role can execute an arbitrary SQL expression.
	Sql []InstanceConfigCredentialsRolesValuePrivilegesElemSqlElem `yaml:"sql,omitempty"`

	// Grants global permissions across all object types in the database, including:
	//
	// - `read`: Read any object
	// - `write`: Modify any object
	// - `execute`: Execute functions or code
	// - `session`: Connect via IPROTO
	// - `usage`: Use granted privileges
	// - `create`: Create users, roles, objects
	// - `drop`: Remove users, roles, objects
	// - `alter`: Modify settings or objects
	Universe *bool `yaml:"universe,omitempty"`
}

type InstanceConfigCredentialsRolesValuePrivilegesElemPermissionsElem string

const InstanceConfigCredentialsRolesValuePrivilegesElemPermissionsElemAlter InstanceConfigCredentialsRolesValuePrivilegesElemPermissionsElem = "alter"
const InstanceConfigCredentialsRolesValuePrivilegesElemPermissionsElemCreate InstanceConfigCredentialsRolesValuePrivilegesElemPermissionsElem = "create"
const InstanceConfigCredentialsRolesValuePrivilegesElemPermissionsElemDrop InstanceConfigCredentialsRolesValuePrivilegesElemPermissionsElem = "drop"
const InstanceConfigCredentialsRolesValuePrivilegesElemPermissionsElemExecute InstanceConfigCredentialsRolesValuePrivilegesElemPermissionsElem = "execute"
const InstanceConfigCredentialsRolesValuePrivilegesElemPermissionsElemRead InstanceConfigCredentialsRolesValuePrivilegesElemPermissionsElem = "read"
const InstanceConfigCredentialsRolesValuePrivilegesElemPermissionsElemSession InstanceConfigCredentialsRolesValuePrivilegesElemPermissionsElem = "session"
const InstanceConfigCredentialsRolesValuePrivilegesElemPermissionsElemUsage InstanceConfigCredentialsRolesValuePrivilegesElemPermissionsElem = "usage"
const InstanceConfigCredentialsRolesValuePrivilegesElemPermissionsElemWrite InstanceConfigCredentialsRolesValuePrivilegesElemPermissionsElem = "write"

type InstanceConfigCredentialsRolesValuePrivilegesElemSqlElem string

const InstanceConfigCredentialsRolesValuePrivilegesElemSqlElemAll InstanceConfigCredentialsRolesValuePrivilegesElemSqlElem = "all"

// An array of users.
type InstanceConfigCredentialsUsers map[string]struct {
	// A user's password.
	Password *string `yaml:"password,omitempty"`

	// An array of privileges granted to this user.
	Privileges []InstanceConfigCredentialsUsersValuePrivilegesElem `yaml:"privileges,omitempty"`

	// An array of roles granted to this user.
	Roles []string `yaml:"roles,omitempty"`
}

// Privileges that can be granted to a user.
type InstanceConfigCredentialsUsersValuePrivilegesElem struct {
	// Registered functions to which this user gets the specified permissions.
	Functions []string `yaml:"functions,omitempty"`

	// Defines the Lua functions that the user has permission to call. This field
	// accepts a special value, `all`, which grants the privilege to use any global
	// non-built-in Lua functions.
	LuaCall []string `yaml:"lua_call,omitempty"`

	// Whether this user can execute arbitrary Lua code.
	LuaEval *bool `yaml:"lua_eval,omitempty"`

	// Permissions assigned to this user or a user with this role.
	Permissions []InstanceConfigCredentialsUsersValuePrivilegesElemPermissionsElem `yaml:"permissions,omitempty"`

	// Sequences to which this user gets the specified permissions.
	Sequences []string `yaml:"sequences,omitempty"`

	// Spaces to which this user gets the specified permissions.
	Spaces []string `yaml:"spaces,omitempty"`

	// Whether this user can execute an arbitrary SQL expression.
	Sql []InstanceConfigCredentialsUsersValuePrivilegesElemSqlElem `yaml:"sql,omitempty"`

	// Grants global permissions across all object types in the database, including:
	//
	// - `read`: Read any object
	// - `write`: Modify any object
	// - `execute`: Execute functions or code
	// - `session`: Connect via IPROTO
	// - `usage`: Use granted privileges
	// - `create`: Create users, roles, objects
	// - `drop`: Remove users, roles, objects
	// - `alter`: Modify settings or objects
	Universe *bool `yaml:"universe,omitempty"`
}

type InstanceConfigCredentialsUsersValuePrivilegesElemPermissionsElem string

const InstanceConfigCredentialsUsersValuePrivilegesElemPermissionsElemAlter InstanceConfigCredentialsUsersValuePrivilegesElemPermissionsElem = "alter"
const InstanceConfigCredentialsUsersValuePrivilegesElemPermissionsElemCreate InstanceConfigCredentialsUsersValuePrivilegesElemPermissionsElem = "create"
const InstanceConfigCredentialsUsersValuePrivilegesElemPermissionsElemDrop InstanceConfigCredentialsUsersValuePrivilegesElemPermissionsElem = "drop"
const InstanceConfigCredentialsUsersValuePrivilegesElemPermissionsElemExecute InstanceConfigCredentialsUsersValuePrivilegesElemPermissionsElem = "execute"
const InstanceConfigCredentialsUsersValuePrivilegesElemPermissionsElemRead InstanceConfigCredentialsUsersValuePrivilegesElemPermissionsElem = "read"
const InstanceConfigCredentialsUsersValuePrivilegesElemPermissionsElemSession InstanceConfigCredentialsUsersValuePrivilegesElemPermissionsElem = "session"
const InstanceConfigCredentialsUsersValuePrivilegesElemPermissionsElemUsage InstanceConfigCredentialsUsersValuePrivilegesElemPermissionsElem = "usage"
const InstanceConfigCredentialsUsersValuePrivilegesElemPermissionsElemWrite InstanceConfigCredentialsUsersValuePrivilegesElemPermissionsElem = "write"

type InstanceConfigCredentialsUsersValuePrivilegesElemSqlElem string

const InstanceConfigCredentialsUsersValuePrivilegesElemSqlElemAll InstanceConfigCredentialsUsersValuePrivilegesElemSqlElem = "all"

// The `database` section defines database-specific configuration parameters, such
// as an instance's read-write mode or transaction isolation level.
type InstanceConfigDatabase struct {
	// Whether to start the server in the hot standby mode. This mode can be used to
	// provide failover without replication.
	//
	// Note: `database.hot_standby` has no effect:
	//
	// - If `wal.mode` is set to none.
	// - If `wal.dir_rescan_delay` is set to a large value on macOS or FreeBSD. On
	// these platforms, the hot standby mode is designed so that the loop repeats
	// every `wal.dir_rescan_delay` seconds.
	// - For spaces created with engine set to `vinyl`.
	HotStandby bool `yaml:"hot_standby,omitempty"`

	// An instance UUID.
	//
	// By default, instance UUIDs are generated automatically.
	// `database.instance_uuid` can be used to specify an instance identifier
	// manually.
	//
	// UUIDs should follow these rules:
	//
	// - The values must be true unique identifiers, not shared by other instances or
	// replica sets within the common infrastructure.
	// - The values must be used consistently, not changed after the initial setup.
	// The initial values are stored in snapshot files and are checked whenever the
	// system is restarted.
	// - The values must comply with RFC 4122. The nil UUID is not allowed.
	//
	// Note: when upgrading from 2.x, `instance_uuid` and `replicaset_uuid` must be
	// explicitly set in the configuration until the database schema upgrade is
	// completed. After a full upgrade, these UUIDs can be removed from the
	// configuration.
	InstanceUuid *string `yaml:"instance_uuid,omitempty"`

	// An instance's operating mode. This option is in effect if
	// `replication.failover` is set to `off`.
	//
	// The following modes are available:
	//
	// - `rw`: an instance is in read-write mode.
	// - `ro`: an instance is in read-only mode.
	//
	// If not specified explicitly, the default value depends on the number of
	// instances in a replica set. For a single instance, the `rw` mode is used, while
	// for multiple instances, the `ro` mode is used.
	Mode *InstanceConfigDatabaseMode `yaml:"mode,omitempty"`

	// A replica set UUID.
	//
	// By default, replica set UUIDs are generated automatically.
	// `database.replicaset_uuid` can be used to specify a replica set identifier
	// manually.
	//
	// Note: when upgrading from 2.x, `instance_uuid` and `replicaset_uuid` must be
	// explicitly set in the configuration until the database schema upgrade is
	// completed. After a full upgrade, these UUIDs can be removed from the
	// configuration.
	ReplicasetUuid *string `yaml:"replicaset_uuid,omitempty"`

	// A transaction isolation level.
	TxnIsolation InstanceConfigDatabaseTxnIsolation `yaml:"txn_isolation,omitempty"`

	// A timeout (in seconds) after which the transaction is rolled back.
	TxnTimeout float64 `yaml:"txn_timeout,omitempty"`

	// Whether the transactional manager is enabled.
	UseMvccEngine bool `yaml:"use_mvcc_engine,omitempty"`
}

type InstanceConfigDatabaseMode string

const InstanceConfigDatabaseModeRo InstanceConfigDatabaseMode = "ro"
const InstanceConfigDatabaseModeRw InstanceConfigDatabaseMode = "rw"

type InstanceConfigDatabaseTxnIsolation string

const InstanceConfigDatabaseTxnIsolationBestEffort InstanceConfigDatabaseTxnIsolation = "best-effort"
const InstanceConfigDatabaseTxnIsolationReadCommitted InstanceConfigDatabaseTxnIsolation = "read-committed"
const InstanceConfigDatabaseTxnIsolationReadConfirmed InstanceConfigDatabaseTxnIsolation = "read-confirmed"

// The `failover` section defines parameters related to a supervised failover.
type InstanceConfigFailover struct {
	// A call timeout (in seconds) for connections used by monitoring and autofailover
	// components.
	CallTimeout float64 `yaml:"call_timeout,omitempty"`

	// A connection timeout (in seconds) for connections used by monitoring and
	// autofailover components.
	ConnectTimeout float64 `yaml:"connect_timeout,omitempty"`

	// A time interval (in seconds) that specifies how long an instance should be a
	// leader without renew requests from a coordinator. When this interval expires,
	// the leader switches to read-only mode. This action is performed by the instance
	// itself and works even if there is no connectivity between the instance and the
	// coordinator.
	LeaseInterval float64 `yaml:"lease_interval,omitempty"`

	// This section defines configuration parameters related to logging for the
	// supervised failover coordinator.
	Log *InstanceConfigFailoverLog `yaml:"log,omitempty"`

	// A time interval (in seconds) that specifies how often a monitoring service of
	// the failover coordinator polls an instance for its status.
	ProbeInterval float64 `yaml:"probe_interval,omitempty"`

	// A time interval (in seconds) that specifies how often a failover coordinator
	// sends read-write deadline renewals.
	RenewInterval float64 `yaml:"renew_interval,omitempty"`

	// Failover coordinator options configured on the per-replicaset basis.
	Replicasets InstanceConfigFailoverReplicasets `yaml:"replicasets,omitempty"`

	// This options define configuration parameters related to maintaining the state
	// of failover coordinators in a remote etcd-based storage.
	Stateboard *InstanceConfigFailoverStateboard `yaml:"stateboard,omitempty"`
}

// This section defines configuration parameters related to logging for the
// supervised failover coordinator.
type InstanceConfigFailoverLog struct {
	// Specify a file for failover logs destination. To write logs to a file, you need
	// to set `failover.log.to` to `file`. Otherwise, `failover.log.file` is ignored.
	File *string `yaml:"file,omitempty"`

	// Define the location for failover logs. This option accepts the following
	// values:
	//
	// - `stderr`: write logs to the standard error stream
	// - `file`: write logs to a file defined in `failover.log.file`
	To InstanceConfigFailoverLogTo `yaml:"to,omitempty"`
}

type InstanceConfigFailoverLogTo string

const InstanceConfigFailoverLogToFile InstanceConfigFailoverLogTo = "file"
const InstanceConfigFailoverLogToStderr InstanceConfigFailoverLogTo = "stderr"

// Failover coordinator options configured on the per-replicaset basis.
type InstanceConfigFailoverReplicasets map[string]struct {
	// Specify instances that are ignored by the supervised failover coordinator when
	// selecting a master.
	//
	// Note: if a learner instance is in RW mode, the coordinator stops the failover
	// process and waits until the instance transitions to RO mode.
	Learners []string `yaml:"learners,omitempty"`

	// Priorities for the supervised failover mode.
	Priority InstanceConfigFailoverReplicasetsValuePriority `yaml:"priority,omitempty"`
}

// Priorities for the supervised failover mode.
type InstanceConfigFailoverReplicasetsValuePriority map[string]float64

// This options define configuration parameters related to maintaining the state of
// failover coordinators in a remote etcd-based storage.
type InstanceConfigFailoverStateboard struct {
	// Enable or disable the failover coordinator stateboard.
	Enabled bool `yaml:"enabled,omitempty"`

	// A time interval (in seconds) that specifies how long a transient state
	// information is stored and how quickly a lock expires.
	//
	// Note `failover.stateboard.keepalive_interval` should be smaller than
	// `failover.lease_interval`. Otherwise, switching of a coordinator causes a
	// replica set leader to go to read-only mode for some time.
	KeepaliveInterval float64 `yaml:"keepalive_interval,omitempty"`

	// A time interval (in seconds) that specifies how often a failover coordinator
	// writes its state information to etcd. This option also determines the frequency
	// at which an active coordinator reads new commands from etcd.
	RenewInterval float64 `yaml:"renew_interval,omitempty"`
}

// The `feedback` section describes configuration parameters for sending
// information about a running Tarantool instance to the specified feedback server.
type InstanceConfigFeedback struct {
	// Whether to send crash information in the case of an instance failure. This
	// information includes:
	//
	// - General information from the `uname` output.
	// - Build information.
	// - The crash reason.
	// - The stack trace.
	//
	// To turn off sending crash information, set this option to `false`.
	Crashinfo bool `yaml:"crashinfo,omitempty"`

	// Whether to send information about a running instance to the feedback server. To
	// turn off sending feedback, set this option to `false`.
	Enabled bool `yaml:"enabled,omitempty"`

	// The address to which information is sent.
	Host string `yaml:"host,omitempty"`

	// The interval (in seconds) of sending information.
	Interval float64 `yaml:"interval,omitempty"`

	// The interval (in seconds) for collecting metrics.
	MetricsCollectInterval float64 `yaml:"metrics_collect_interval,omitempty"`

	// The maximum size of memory (in bytes) used to store metrics before sending them
	// to the feedback server. If the size of collected metrics exceeds this value,
	// earlier metrics are dropped.
	MetricsLimit int `yaml:"metrics_limit,omitempty"`

	// Whether to send metrics to the feedback server. Note that all collected metrics
	// are dropped after sending them to the feedback server.
	SendMetrics bool `yaml:"send_metrics,omitempty"`
}

// The `fiber` section describes options related to configuring fibers, yields, and
// cooperative multitasking.
type InstanceConfigFiber struct {
	// The time period (in seconds) a fiber sleeps between iterations of the event
	// loop.
	//
	// `fiber.io_collect_interval` can be used to reduce CPU load in deployments where
	// the number of client connections is large, but requests are not so frequent
	// (for example, each connection issues just a handful of requests per second).
	IoCollectInterval *float64 `yaml:"io_collect_interval,omitempty"`

	// This section describes options related to configuring time periods for fiber
	// slices. See `fiber.set_max_slice` for details and examples.
	Slice *InstanceConfigFiberSlice `yaml:"slice,omitempty"`

	// If processing a request takes longer than the given period (in seconds), the
	// fiber warns about it in the log.
	//
	// `fiber.too_long_threshold` has effect only if `log.level` is greater than or
	// equal to 4 (`warn`).
	TooLongThreshold float64 `yaml:"too_long_threshold,omitempty"`

	// This section describes options related to configuring the `fiber.top()`
	// function, normally used for debug purposes. `fiber.top()` shows all alive
	// fibers and their CPU consumption.
	Top *InstanceConfigFiberTop `yaml:"top,omitempty"`

	// Specify the size of the fiber pool used in the TX thread for executing
	// user-defined callbacks pushed via the `tnt_tx_push()` C API function. This pool
	// operates similarly to the fiber pool for handling IProto requests, whose size
	// is defined by `box.cfg.net_msg_max`.
	//
	// Increase the pool size if the application requires executing a large number of
	// concurrent callbacks, especially if they involve yielding operations or high
	// transaction loads.
	//
	// Notes:
	//
	// - The callbacks are executed in the order they are pushed, but the completion
	// order is undefined for yielding callbacks
	// - Mismanaging the pool size or callback rate can lead to unpredictable latency
	// or memory overflows (OOM)
	TxUserPoolSize int `yaml:"tx_user_pool_size,omitempty"`

	// The maximum number of threads to use during execution of certain internal
	// processes (for example, `socket.getaddrinfo()` and `coio_call()`).
	WorkerPoolThreads float64 `yaml:"worker_pool_threads,omitempty"`
}

// This section describes options related to configuring time periods for fiber
// slices. See `fiber.set_max_slice` for details and examples.
type InstanceConfigFiberSlice struct {
	// Set a time period (in seconds) that specifies the warning slice.
	Err float64 `yaml:"err,omitempty"`

	// Set a time period (in seconds) that specifies the error slice.
	Warn float64 `yaml:"warn,omitempty"`
}

// This section describes options related to configuring the `fiber.top()`
// function, normally used for debug purposes. `fiber.top()` shows all alive fibers
// and their CPU consumption.
type InstanceConfigFiberTop struct {
	// Enable or disable the `fiber.top()` function.
	//
	// Enabling `fiber.top()` slows down fiber switching by about 15%, so it is
	// disabled by default.
	Enabled bool `yaml:"enabled,omitempty"`
}

// The flightrec section describes options related to the flight recorder
// configuration.
type InstanceConfigFlightrec struct {
	// Enable the flight recorder.
	Enabled bool `yaml:"enabled,omitempty"`

	// Specify the level of detail the log has. The default value is 6 (`VERBOSE`).
	// You can learn more about log levels from the log_level option description. Note
	// that the `flightrec.logs_log_level` value might differ from `log_level`.
	LogsLogLevel InstanceConfigFlightrecLogsLogLevel `yaml:"logs_log_level,omitempty"`

	// Specify the maximum size (in bytes) of the log message. The log message is
	// truncated if its size exceeds this limit.
	LogsMaxMsgSize int `yaml:"logs_max_msg_size,omitempty"`

	// Specify the size (in bytes) of the log storage. You can set this option to 0 to
	// disable the log storage.
	LogsSize int `yaml:"logs_size,omitempty"`

	// Specify the time interval (in seconds) that defines the frequency of dumping
	// metrics. This value shouldn't exceed `flightrec.metrics_period`.
	MetricsInterval float64 `yaml:"metrics_interval,omitempty"`

	// Specify the time period (in seconds) that defines how long metrics are stored
	// from the moment of dump. So, this value defines how much historical metrics
	// data is collected up to the moment of crash. The frequency of metric dumps is
	// defined by `flightrec.metrics_interval`.
	MetricsPeriod float64 `yaml:"metrics_period,omitempty"`

	// Specify the maximum size (in bytes) of a request entry. A request entry is
	// truncated if this size is exceeded.
	RequestsMaxReqSize int `yaml:"requests_max_req_size,omitempty"`

	// Specify the maximum size (in bytes) of a response entry. A response entry is
	// truncated if this size is exceeded.
	RequestsMaxResSize int `yaml:"requests_max_res_size,omitempty"`

	// Specify the size (in bytes) of storage for the request and response data. You
	// can set this parameter to 0 to disable a storage of requests and responses.
	RequestsSize int `yaml:"requests_size,omitempty"`
}

type InstanceConfigFlightrecLogsLogLevel int

// The iproto section is used to configure parameters related to communicating to
// and between cluster instances.
type InstanceConfigIproto struct {
	// URIs for cluster members and external clients to let them know where to
	// connect.
	Advertise *InstanceConfigIprotoAdvertise `yaml:"advertise,omitempty"`

	// An array of URIs used to listen for incoming requests. If required, you can
	// enable SSL for specific URIs by providing additional parameters
	// (`iproto.listen.*.params`).
	Listen []InstanceConfigIprotoListenElem `yaml:"listen,omitempty"`

	// To handle messages, Tarantool allocates fibers. To prevent fiber overhead from
	// affecting the whole system, Tarantool restricts how many messages the fibers
	// handle, so that some pending requests are blocked.
	//
	// - On powerful systems, increase `net_msg_max`, and the scheduler starts
	// processing pending requests immediately.
	// - On weaker systems, decrease `net_msg_max`, and the overhead may decrease.
	// However, this may take some time because the scheduler must wait until
	// already-running requests finish.
	//
	// When `net_msg_max` is reached, Tarantool suspends processing of incoming
	// packages until it has processed earlier messages. This is not a direct
	// restriction of the number of fibers that handle network messages, rather it is
	// a system-wide restriction of channel bandwidth. This in turn restricts the
	// number of incoming network messages that the transaction processor thread
	// handles, and therefore indirectly affects the fibers that handle network
	// messages.
	NetMsgMax int `yaml:"net_msg_max,omitempty"`

	// The size of the read-ahead buffer associated with a client connection. The
	// larger the buffer, the more memory an active connection consumes, and the more
	// requests can be read from the operating system buffer in a single system call.
	//
	// The recommendation is to make sure that the buffer can contain at least a few
	// dozen requests. Therefore, if a typical tuple in a request is large, e.g. a few
	// kilobytes or even megabytes, the read-ahead buffer size should be increased. If
	// batched request processing is not used, it's prudent to leave this setting at
	// its default.
	Readahead int `yaml:"readahead,omitempty"`

	// The number of network threads. There can be unusual workloads where the network
	// thread is 100% loaded and the transaction processor thread is not, so the
	// network thread is a bottleneck. In that case, set `iproto_threads` to 2 or
	// more. The operating system kernel determines which connection goes to which
	// thread.
	Threads int `yaml:"threads,omitempty"`
}

// URIs for cluster members and external clients to let them know where to connect.
type InstanceConfigIprotoAdvertise struct {
	// A URI used to advertise the current instance to clients.
	//
	// The iproto.advertise.client option accepts a URI in the following formats:
	//
	// - An address: `host:port`.
	// - A Unix domain socket: `unix/:`.
	//
	// Note that this option doesn't allow to set a username and password. If a remote
	// client needs this information, it should be delivered outside of the cluster
	// configuration.
	Client *string `yaml:"client,omitempty"`

	// Settings used to advertise the current instance to other cluster members. The
	// format of these settings is described in
	// `iproto.advertise.<peer_or_sharding>.*`.
	Peer *InstanceConfigIprotoAdvertisePeer `yaml:"peer,omitempty"`

	// Settings used to advertise the current instance to a router and rebalancer. The
	// format of these settings is described in
	// `iproto.advertise.<peer_or_sharding>.*`.
	Sharding *InstanceConfigIprotoAdvertiseSharding `yaml:"sharding,omitempty"`
}

// Settings used to advertise the current instance to other cluster members. The
// format of these settings is described in
// `iproto.advertise.<peer_or_sharding>.*`.
type InstanceConfigIprotoAdvertisePeer struct {
	// (Optional) A username used to connect to the current instance. If a username is
	// not set, the guest user is used.
	Login *string `yaml:"login,omitempty"`

	// SSL parameters required for encrypted connections.
	Params *InstanceConfigIprotoAdvertisePeerParams `yaml:"params,omitempty"`

	// (Optional) A password for the specified user. If a login is specified but a
	// password is missing, it is taken from the user's credentials.
	Password *string `yaml:"password,omitempty"`

	// (Optional) A URI used to advertise the current instance. By default, the URI
	// defined in iproto.listen is used to advertise the current instance.
	Uri *string `yaml:"uri,omitempty"`
}

// SSL parameters required for encrypted connections.
type InstanceConfigIprotoAdvertisePeerParams struct {
	// (Optional) A path to a trusted certificate authorities (CA) file. If not set,
	// the peer won't be checked for authenticity.
	//
	// Both a server and a client can use the ssl_ca_file parameter:
	//
	// - If it's on the server side, the server verifies the client.
	// - If it's on the client side, the client verifies the server.
	// - If both sides have the CA files, the server and the client verify each other.
	SslCaFile *string `yaml:"ssl_ca_file,omitempty"`

	// A path to an SSL certificate file:
	//
	// - For a server, it's mandatory.
	// - For a client, it's mandatory if the ssl_ca_file parameter is set for a
	// server; otherwise, optional.
	SslCertFile *string `yaml:"ssl_cert_file,omitempty"`

	// (Optional) A colon-separated (:) list of SSL cipher suites the connection can
	// use. Note that the list is not validated: if a cipher suite is unknown,
	// Tarantool ignores it, doesn't establish the connection, and writes to the log
	// that no shared cipher was found.
	SslCiphers *string `yaml:"ssl_ciphers,omitempty"`

	// A path to a private SSL key file:
	//
	// - For a server, it's mandatory.
	// - For a client, it's mandatory if the `ssl_ca_file` parameter is set for a
	// server; otherwise, optional.
	//
	// If the private key is encrypted, provide a password for it in the
	// `ssl_password` or `ssl_password_file` parameter
	SslKeyFile *string `yaml:"ssl_key_file,omitempty"`

	// (Optional) A password for an encrypted private SSL key provided using
	// `ssl_key_file`. Alternatively, the password can be provided in
	// `ssl_password_file`.
	//
	// Tarantool applies the `ssl_password` and `ssl_password_file` parameters in the
	// following order:
	//
	// - If `ssl_password` is provided, Tarantool tries to decrypt the private key
	// with it.
	// - If `ssl_password` is incorrect or isn't provided, Tarantool tries all
	// passwords from `ssl_password_file` one by one in the order they are written.
	// - If `ssl_password` and all passwords from `ssl_password_file` are incorrect,
	// or none of them is provided, Tarantool treats the private key as unencrypted.
	SslPassword *string `yaml:"ssl_password,omitempty"`

	// (Optional) A text file with one or more passwords for encrypted private SSL
	// keys provided using `ssl_key_file` (each on a separate line). Alternatively,
	// the password can be provided in `ssl_password`.
	SslPasswordFile *string `yaml:"ssl_password_file,omitempty"`

	// Allows you to enable traffic encryption for client-server communications over
	// binary connections. In a Tarantool cluster, one instance might act as the
	// server that accepts connections from other instances and the client that
	// connects to other instances.
	//
	// `<uri>.params.transport` accepts one of the following values:
	//
	// - `plain` (default): turn off traffic encryption,
	// - `ssl`: encrypt traffic by using the TLS 1.2 protocol (EE only).
	Transport *InstanceConfigIprotoAdvertisePeerParamsTransport `yaml:"transport,omitempty"`
}

type InstanceConfigIprotoAdvertisePeerParamsTransport string

const InstanceConfigIprotoAdvertisePeerParamsTransportPlain InstanceConfigIprotoAdvertisePeerParamsTransport = "plain"
const InstanceConfigIprotoAdvertisePeerParamsTransportSsl InstanceConfigIprotoAdvertisePeerParamsTransport = "ssl"

// Settings used to advertise the current instance to a router and rebalancer. The
// format of these settings is described in
// `iproto.advertise.<peer_or_sharding>.*`.
type InstanceConfigIprotoAdvertiseSharding struct {
	// (Optional) A username used to connect to the current instance. If a username is
	// not set, the guest user is used.
	Login *string `yaml:"login,omitempty"`

	// SSL parameters required for encrypted connections.
	Params *InstanceConfigIprotoAdvertiseShardingParams `yaml:"params,omitempty"`

	// (Optional) A password for the specified user. If a login is specified but a
	// password is missing, it is taken from the user's credentials.
	Password *string `yaml:"password,omitempty"`

	// (Optional) A URI used to advertise the current instance. By default, the URI
	// defined in iproto.listen is used to advertise the current instance.
	Uri *string `yaml:"uri,omitempty"`
}

// SSL parameters required for encrypted connections.
type InstanceConfigIprotoAdvertiseShardingParams struct {
	// (Optional) A path to a trusted certificate authorities (CA) file. If not set,
	// the peer won't be checked for authenticity.
	//
	// Both a server and a client can use the ssl_ca_file parameter:
	//
	// - If it's on the server side, the server verifies the client.
	// - If it's on the client side, the client verifies the server.
	// - If both sides have the CA files, the server and the client verify each other.
	SslCaFile *string `yaml:"ssl_ca_file,omitempty"`

	// A path to an SSL certificate file:
	//
	// - For a server, it's mandatory.
	// - For a client, it's mandatory if the ssl_ca_file parameter is set for a
	// server; otherwise, optional.
	SslCertFile *string `yaml:"ssl_cert_file,omitempty"`

	// (Optional) A colon-separated (:) list of SSL cipher suites the connection can
	// use. Note that the list is not validated: if a cipher suite is unknown,
	// Tarantool ignores it, doesn't establish the connection, and writes to the log
	// that no shared cipher was found.
	SslCiphers *string `yaml:"ssl_ciphers,omitempty"`

	// A path to a private SSL key file:
	//
	// - For a server, it's mandatory.
	// - For a client, it's mandatory if the `ssl_ca_file` parameter is set for a
	// server; otherwise, optional.
	//
	// If the private key is encrypted, provide a password for it in the
	// `ssl_password` or `ssl_password_file` parameter
	SslKeyFile *string `yaml:"ssl_key_file,omitempty"`

	// (Optional) A password for an encrypted private SSL key provided using
	// `ssl_key_file`. Alternatively, the password can be provided in
	// `ssl_password_file`.
	//
	// Tarantool applies the `ssl_password` and `ssl_password_file` parameters in the
	// following order:
	//
	// - If `ssl_password` is provided, Tarantool tries to decrypt the private key
	// with it.
	// - If `ssl_password` is incorrect or isn't provided, Tarantool tries all
	// passwords from `ssl_password_file` one by one in the order they are written.
	// - If `ssl_password` and all passwords from `ssl_password_file` are incorrect,
	// or none of them is provided, Tarantool treats the private key as unencrypted.
	SslPassword *string `yaml:"ssl_password,omitempty"`

	// (Optional) A text file with one or more passwords for encrypted private SSL
	// keys provided using `ssl_key_file` (each on a separate line). Alternatively,
	// the password can be provided in `ssl_password`.
	SslPasswordFile *string `yaml:"ssl_password_file,omitempty"`

	// Allows you to enable traffic encryption for client-server communications over
	// binary connections. In a Tarantool cluster, one instance might act as the
	// server that accepts connections from other instances and the client that
	// connects to other instances.
	//
	// `<uri>.params.transport` accepts one of the following values:
	//
	// - `plain` (default): turn off traffic encryption,
	// - `ssl`: encrypt traffic by using the TLS 1.2 protocol (EE only).
	Transport *InstanceConfigIprotoAdvertiseShardingParamsTransport `yaml:"transport,omitempty"`
}

type InstanceConfigIprotoAdvertiseShardingParamsTransport string

const InstanceConfigIprotoAdvertiseShardingParamsTransportPlain InstanceConfigIprotoAdvertiseShardingParamsTransport = "plain"
const InstanceConfigIprotoAdvertiseShardingParamsTransportSsl InstanceConfigIprotoAdvertiseShardingParamsTransport = "ssl"

// Iproto listening socket definition.
//
// Allows to set an URI (`unix/:<path>` or `host:port`) and SSL parameters. Minimal
// example: `{uri: 127.0.0.1:3301}`.
type InstanceConfigIprotoListenElem struct {
	// SSL parameters required for encrypted connections.
	Params *InstanceConfigIprotoListenElemParams `yaml:"params,omitempty"`

	// An array of URIs used to listen for incoming requests. If required, you can
	// enable SSL for specific URIs by providing additional parameters
	// (`iproto.listen.*.params`).
	//
	// Note: the `iproto.listen.*.uri` string can't contain a login or a password, it
	// has no sense for a listening socket.
	//
	// The query-parameter form of setting SSL options is forbidden in the URI string.
	// Use the `iproto.listen.*.params` for them.
	Uri *string `yaml:"uri,omitempty"`
}

// SSL parameters required for encrypted connections.
type InstanceConfigIprotoListenElemParams struct {
	// (Optional) A path to a trusted certificate authorities (CA) file. If not set,
	// the peer won't be checked for authenticity.
	//
	// Both a server and a client can use the ssl_ca_file parameter:
	//
	// - If it's on the server side, the server verifies the client.
	// - If it's on the client side, the client verifies the server.
	// - If both sides have the CA files, the server and the client verify each other.
	SslCaFile *string `yaml:"ssl_ca_file,omitempty"`

	// A path to an SSL certificate file:
	//
	// - For a server, it's mandatory.
	// - For a client, it's mandatory if the ssl_ca_file parameter is set for a
	// server; otherwise, optional.
	SslCertFile *string `yaml:"ssl_cert_file,omitempty"`

	// (Optional) A colon-separated (:) list of SSL cipher suites the connection can
	// use. Note that the list is not validated: if a cipher suite is unknown,
	// Tarantool ignores it, doesn't establish the connection, and writes to the log
	// that no shared cipher was found.
	SslCiphers *string `yaml:"ssl_ciphers,omitempty"`

	// A path to a private SSL key file:
	//
	// - For a server, it's mandatory.
	// - For a client, it's mandatory if the `ssl_ca_file` parameter is set for a
	// server; otherwise, optional.
	//
	// If the private key is encrypted, provide a password for it in the
	// `ssl_password` or `ssl_password_file` parameter
	SslKeyFile *string `yaml:"ssl_key_file,omitempty"`

	// (Optional) A password for an encrypted private SSL key provided using
	// `ssl_key_file`. Alternatively, the password can be provided in
	// `ssl_password_file`.
	//
	// Tarantool applies the `ssl_password` and `ssl_password_file` parameters in the
	// following order:
	//
	// - If `ssl_password` is provided, Tarantool tries to decrypt the private key
	// with it.
	// - If `ssl_password` is incorrect or isn't provided, Tarantool tries all
	// passwords from `ssl_password_file` one by one in the order they are written.
	// - If `ssl_password` and all passwords from `ssl_password_file` are incorrect,
	// or none of them is provided, Tarantool treats the private key as unencrypted.
	SslPassword *string `yaml:"ssl_password,omitempty"`

	// (Optional) A text file with one or more passwords for encrypted private SSL
	// keys provided using `ssl_key_file` (each on a separate line). Alternatively,
	// the password can be provided in `ssl_password`.
	SslPasswordFile *string `yaml:"ssl_password_file,omitempty"`

	// Allows you to enable traffic encryption for client-server communications over
	// binary connections. In a Tarantool cluster, one instance might act as the
	// server that accepts connections from other instances and the client that
	// connects to other instances.
	//
	// `<uri>.params.transport` accepts one of the following values:
	//
	// - `plain` (default): turn off traffic encryption,
	// - `ssl`: encrypt traffic by using the TLS 1.2 protocol (EE only).
	Transport *InstanceConfigIprotoListenElemParamsTransport `yaml:"transport,omitempty"`
}

type InstanceConfigIprotoListenElemParamsTransport string

const InstanceConfigIprotoListenElemParamsTransportPlain InstanceConfigIprotoListenElemParamsTransport = "plain"
const InstanceConfigIprotoListenElemParamsTransportSsl InstanceConfigIprotoListenElemParamsTransport = "ssl"

// The `labels` section allows adding custom attributes to the instance. The keys
// and values are strings.
type InstanceConfigLabels map[string]string

// The `log` section defines configuration parameters related to logging. To handle
// logging in your application, use the log module.
type InstanceConfigLog struct {
	// Specify a file for logs destination. To write logs to a file, you need to set
	// `log.to` to file. Otherwise, `log.file` is ignored.
	File string `yaml:"file,omitempty"`

	// Specify a format that is used for a log entry. The following formats are
	// supported:
	//
	// - `plain`: a log entry is formatted as plain text.
	// - `json`: a log entry is formatted as JSON and includes additional fields.
	Format InstanceConfigLogFormat `yaml:"format,omitempty"`

	// Configure the specified log levels (`log.level`) for different modules.
	//
	// You can specify a logging level for the following module types:
	//
	// - Modules (files) that use the default logger.
	// - Modules that use custom loggers created using the `log.new()` function.
	// - The tarantool module that enables you to configure the logging level for
	// Tarantool core messages. Specifically, it configures the logging level for
	// messages logged from non-Lua code, including C modules.
	Modules InstanceConfigLogModules `yaml:"modules,omitempty"`

	// Specify the logging behavior if the system is not ready to write. If set to
	// `true`, Tarantool does not block during logging if the system is non-writable
	// and writes a message instead. Using this value may improve logging performance
	// at the cost of losing some log messages.
	Nonblock bool `yaml:"nonblock,omitempty"`

	// Start a program and write logs to its standard input (`stdin`). To send logs to
	// a program's standard input, you need to set `log.to` to `pipe`.
	Pipe *string `yaml:"pipe,omitempty"`

	// Syslog configurations parameters. To write logs to syslog, you need to set
	// `log.to` to `syslog`.
	Syslog *InstanceConfigLogSyslog `yaml:"syslog,omitempty"`

	// Define a location Tarantool sends logs to. This option accepts the following
	// values:
	//
	// - `stderr`: write logs to the standard error stream.
	// - `file`: write logs to a file.
	// - `pipe`: start a program and write logs to its standard input.
	// - `syslog`: write logs to a system logger.
	To InstanceConfigLogTo `yaml:"to,omitempty"`
}

type InstanceConfigLogFormat string

const InstanceConfigLogFormatJson InstanceConfigLogFormat = "json"
const InstanceConfigLogFormatPlain InstanceConfigLogFormat = "plain"

// Configure the specified log levels (`log.level`) for different modules.
//
// You can specify a logging level for the following module types:
//
// - Modules (files) that use the default logger.
// - Modules that use custom loggers created using the `log.new()` function.
// - The tarantool module that enables you to configure the logging level for
// Tarantool core messages. Specifically, it configures the logging level for
// messages logged from non-Lua code, including C modules.
type InstanceConfigLogModules map[string]float64

// Syslog configurations parameters. To write logs to syslog, you need to set
// `log.to` to `syslog`.
type InstanceConfigLogSyslog struct {
	// Specify the syslog facility to be used when syslog is enabled. To write logs to
	// syslog, you need to set `log.to` to `syslog`.
	Facility string `yaml:"facility,omitempty"`

	// Specify an application name used to identify Tarantool messages in syslog logs.
	// To write logs to syslog, you need to set `log.to` to `syslog`.
	Identity string `yaml:"identity,omitempty"`

	// Set a location of a syslog server. This option accepts one of the following
	// values:
	//
	// - An address. Example: `127.0.0.1:514`.
	// - A Unix socket path starting with `unix:`. Examples: `unix:/dev/log` on Linux
	// or `unix:/var/run/syslog` on macOS.
	//
	// To write logs to syslog, you need to set `log.to` to `syslog`.
	Server *string `yaml:"server,omitempty"`
}

type InstanceConfigLogTo string

const InstanceConfigLogToFile InstanceConfigLogTo = "file"
const InstanceConfigLogToPipe InstanceConfigLogTo = "pipe"
const InstanceConfigLogToStderr InstanceConfigLogTo = "stderr"
const InstanceConfigLogToSyslog InstanceConfigLogTo = "syslog"

// This section defines configuration parameters related to Lua within Tarantool.
type InstanceConfigLua struct {
	// Define amount of memory available to Lua in bytes. Default is 2GB, with a
	// minimum of 256MB.
	//
	// The limit can be adjusted dynamically if the new value is greater than the used
	// memory amount. Otherwise, a restart is required for changes to take effect.
	Memory int `yaml:"memory,omitempty"`
}

// This section is used to configure parameters related to the memtx engine.
type InstanceConfigMemtx struct {
	// Specify the allocator that manages memory for memtx tuples. Possible values:
	//
	// - `system` - the memory is allocated as needed, checking that the quota is not
	// exceeded. The allocator is based on the `malloc` function.
	// - `small` - a slab allocator. The allocator repeatedly uses a memory block to
	// allocate objects of the same type. Note that this allocator is prone to
	// unresolvable fragmentation on specific workloads, so you can switch to `system`
	// in such cases.
	Allocator InstanceConfigMemtxAllocator `yaml:"allocator,omitempty"`

	// Size of the largest allocation unit for the memtx storage engine in bytes. It
	// can be increased if it is necessary to store large tuples.
	MaxTupleSize int `yaml:"max_tuple_size,omitempty"`

	// The amount of memory in bytes that Tarantool allocates to store tuples. When
	// the limit is reached, `INSERT` and `UPDATE` requests fail with the
	// `ER_MEMORY_ISSUE` error. The server does not go beyond the `memtx.memory` limit
	// to allocate tuples, but there is additional memory used to store indexes and
	// connection information.
	Memory int `yaml:"memory,omitempty"`

	// Size of the smallest allocation unit in bytes. It can be decreased if most of
	// the tuples are very small.
	MinTupleSize int `yaml:"min_tuple_size,omitempty"`

	// The multiplier for computing the sizes of memory chunks that tuples are stored
	// in. A lower value may result in less wasted memory depending on the total
	// amount of memory available and the distribution of item sizes.
	SlabAllocFactor float64 `yaml:"slab_alloc_factor,omitempty"`

	// Specify the granularity in bytes of memory allocation in the small allocator.
	// The `memtx.slab_alloc_granularity` value should meet the following conditions:
	//
	// - The value is a power of two.
	// - The value is greater than or equal to 4.
	//
	// Below are few recommendations on how to adjust the
	// `memtx.slab_alloc_granularity option`:
	//
	// - If the tuples in space are small and have about the same size, set the option
	// to 4 bytes to save memory.
	// - If the tuples are different-sized, increase the option value to allocate
	// tuples from the same `mempool` (memory pool).
	SlabAllocGranularity int `yaml:"slab_alloc_granularity,omitempty"`

	// The number of threads from the thread pool used to sort keys of secondary
	// indexes on loading a `memtx` database. The minimum value is 1, the maximum
	// value is 256. The default is to use all available cores.
	SortThreads *int `yaml:"sort_threads,omitempty"`
}

type InstanceConfigMemtxAllocator string

const InstanceConfigMemtxAllocatorSmall InstanceConfigMemtxAllocator = "small"
const InstanceConfigMemtxAllocatorSystem InstanceConfigMemtxAllocator = "system"

// The `metrics` section provides the ability to collect and expose Tarantool
// metrics (e.g. network, cpu, memtx and others).
type InstanceConfigMetrics struct {
	// An array containing groups of metrics to turn off. The array can contain the
	// same values as the `exclude` configuration parameter passed to `metrics.cfg()`.
	Exclude []InstanceConfigMetricsExcludeElem `yaml:"exclude,omitempty"`

	// An array containing groups of metrics to turn on. The array can contain the
	// same values as the `include` configuration parameter passed to `metrics.cfg()`.
	Include []InstanceConfigMetricsIncludeElem `yaml:"include,omitempty"`

	// Global labels to be added to every observation.
	Labels InstanceConfigMetricsLabels `yaml:"labels,omitempty"`
}

type InstanceConfigMetricsExcludeElem string

const InstanceConfigMetricsExcludeElemAll InstanceConfigMetricsExcludeElem = "all"
const InstanceConfigMetricsExcludeElemClock InstanceConfigMetricsExcludeElem = "clock"
const InstanceConfigMetricsExcludeElemCpu InstanceConfigMetricsExcludeElem = "cpu"
const InstanceConfigMetricsExcludeElemCpuExtended InstanceConfigMetricsExcludeElem = "cpu_extended"
const InstanceConfigMetricsExcludeElemEventLoop InstanceConfigMetricsExcludeElem = "event_loop"
const InstanceConfigMetricsExcludeElemFibers InstanceConfigMetricsExcludeElem = "fibers"
const InstanceConfigMetricsExcludeElemInfo InstanceConfigMetricsExcludeElem = "info"
const InstanceConfigMetricsExcludeElemLuajit InstanceConfigMetricsExcludeElem = "luajit"
const InstanceConfigMetricsExcludeElemMemory InstanceConfigMetricsExcludeElem = "memory"
const InstanceConfigMetricsExcludeElemMemtx InstanceConfigMetricsExcludeElem = "memtx"
const InstanceConfigMetricsExcludeElemNetwork InstanceConfigMetricsExcludeElem = "network"
const InstanceConfigMetricsExcludeElemOperations InstanceConfigMetricsExcludeElem = "operations"
const InstanceConfigMetricsExcludeElemReplicas InstanceConfigMetricsExcludeElem = "replicas"
const InstanceConfigMetricsExcludeElemRuntime InstanceConfigMetricsExcludeElem = "runtime"
const InstanceConfigMetricsExcludeElemSlab InstanceConfigMetricsExcludeElem = "slab"
const InstanceConfigMetricsExcludeElemSpaces InstanceConfigMetricsExcludeElem = "spaces"
const InstanceConfigMetricsExcludeElemSystem InstanceConfigMetricsExcludeElem = "system"
const InstanceConfigMetricsExcludeElemVinyl InstanceConfigMetricsExcludeElem = "vinyl"

type InstanceConfigMetricsIncludeElem string

const InstanceConfigMetricsIncludeElemAll InstanceConfigMetricsIncludeElem = "all"
const InstanceConfigMetricsIncludeElemClock InstanceConfigMetricsIncludeElem = "clock"
const InstanceConfigMetricsIncludeElemCpu InstanceConfigMetricsIncludeElem = "cpu"
const InstanceConfigMetricsIncludeElemCpuExtended InstanceConfigMetricsIncludeElem = "cpu_extended"
const InstanceConfigMetricsIncludeElemEventLoop InstanceConfigMetricsIncludeElem = "event_loop"
const InstanceConfigMetricsIncludeElemFibers InstanceConfigMetricsIncludeElem = "fibers"
const InstanceConfigMetricsIncludeElemInfo InstanceConfigMetricsIncludeElem = "info"
const InstanceConfigMetricsIncludeElemLuajit InstanceConfigMetricsIncludeElem = "luajit"
const InstanceConfigMetricsIncludeElemMemory InstanceConfigMetricsIncludeElem = "memory"
const InstanceConfigMetricsIncludeElemMemtx InstanceConfigMetricsIncludeElem = "memtx"
const InstanceConfigMetricsIncludeElemNetwork InstanceConfigMetricsIncludeElem = "network"
const InstanceConfigMetricsIncludeElemOperations InstanceConfigMetricsIncludeElem = "operations"
const InstanceConfigMetricsIncludeElemReplicas InstanceConfigMetricsIncludeElem = "replicas"
const InstanceConfigMetricsIncludeElemRuntime InstanceConfigMetricsIncludeElem = "runtime"
const InstanceConfigMetricsIncludeElemSlab InstanceConfigMetricsIncludeElem = "slab"
const InstanceConfigMetricsIncludeElemSpaces InstanceConfigMetricsIncludeElem = "spaces"
const InstanceConfigMetricsIncludeElemSystem InstanceConfigMetricsIncludeElem = "system"
const InstanceConfigMetricsIncludeElemVinyl InstanceConfigMetricsIncludeElem = "vinyl"

// Global labels to be added to every observation.
type InstanceConfigMetricsLabels map[string]string

// The `process` section defines configuration parameters of the Tarantool process
// in the system.
type InstanceConfigProcess struct {
	// Run the server as a daemon process.
	//
	// If this option is set to true, Tarantool log location defined by the `log.to`
	// option should be set to file, pipe, or syslog - anything other than stderr, the
	// default, because a daemon process is detached from a terminal and it can't
	// write to the terminal's stderr.
	//
	// Warn: Do not enable the background mode for applications intended to run by the
	// tt utility.
	Background bool `yaml:"background,omitempty"`

	// Create coredump files.
	//
	// Usually, an administrator needs to call `ulimit -c unlimited` (or set
	// corresponding options in systemd's unit file) before running a Tarantool
	// process to get core dumps. If `process.coredump` is enabled, Tarantool sets the
	// corresponding resource limit by itself and the administrator doesn't need to
	// call `ulimit -c unlimited` (see man 3 setrlimit).
	//
	// This option also sets the state of the `dumpable` attribute, which is enabled
	// by default, but may be dropped in some circumstances (according to man 2 prctl,
	// see PR_SET_DUMPABLE).
	Coredump bool `yaml:"coredump,omitempty"`

	// Store the process id in this file.
	//
	// This option may contain a relative file path. In this case, it is interpreted
	// as relative to `process.work_dir`.
	PidFile string `yaml:"pid_file,omitempty"`

	// Whether coredump files should not include memory allocated for tuples - this
	// memory can be large if Tarantool runs under heavy load. Setting to `true` means
	// "do not include".
	StripCore bool `yaml:"strip_core,omitempty"`

	// Add the given string to the server's process title (it is shown in the COMMAND
	// column for the Linux commands `ps -ef` and `top -c`).
	Title string `yaml:"title,omitempty"`

	// The name of the system user to switch to after start.
	Username *string `yaml:"username,omitempty"`

	// A directory where Tarantool working files will be stored (database files, logs,
	// a PID file, a console Unix socket, and other files if an application generates
	// them in the current directory). The server instance switches to
	// `process.work_dir` with chdir(2) after start.
	//
	// If set as a relative file path, it is relative to the current working
	// directory, from where Tarantool is started. If not specified, defaults to the
	// current working directory.
	//
	// Other directory and file parameters, if set as relative paths, are interpreted
	// as relative to `process.work_dir`, for example, directories for storing
	// snapshots and write-ahead logs.
	WorkDir *string `yaml:"work_dir,omitempty"`
}

// This section defines configuration parameters related to replication.
type InstanceConfigReplication struct {
	// Whether to make the current instance act as an anonymous replica. Anonymous
	// replicas are read-only and can be used, for example, for backups.
	//
	// To make the specified instance act as an anonymous replica, set
	// `replication.anon` to `true`.
	//
	// Anonymous replicas are not displayed in the `box.info.replication` section. You
	// can check their status using `box.info.replication_anon()`.
	//
	// While anonymous replicas are read-only, you can write data to replication-local
	// and temporary spaces (created with `is_local = true` and `temporary = true`,
	// respectively). Given that changes to replication-local spaces are allowed, an
	// anonymous replica might increase the 0 component of the vclock value.
	//
	// Here are the limitations of having anonymous replicas in a replica set:
	//
	// - A replica set must contain at least one non-anonymous instance.
	// - An anonymous replica can't be configured as a writable instance by setting
	// database.mode to rw or making it a leader using `<replicaset_name>.leader.`
	// - If `replication.failover` is set to election, an anonymous replica can have
	// `replication.election_mode` set to `off` only.
	// - If `replication.failover` is set to `supervised`, an external failover
	// coordinator doesn't consider anonymous replicas when selecting a bootstrap or
	// replica set leader.
	Anon bool `yaml:"anon,omitempty"`

	// Time-to-live (in seconds) of disconnected anonymous replicas (see
	// `replication.anon` for the definition of anonymous replica). If an anonymous
	// replica hasn't been in touch for longer than `replication.anon_ttl`, it is
	// removed from the instance.
	AnonTtl float64 `yaml:"anon_ttl,omitempty"`

	// Automatically expel instances.
	//
	// The option is useful for management of dynamic clusters using the YAML
	// configuration. The option allows to automatically expel instances that are
	// removed from the YAML configuration.
	//
	// Only instances whose names start from the given prefix are taken into account,
	// all the others are ignored. Also, instances without a persistent name set are
	// ignored too.
	//
	// If an instance is in read-write mode and has a latest database schema, it
	// performs expelling of the instances:
	//
	// - with the given prefix, *and*
	// - not present in the YAML configuration.
	//
	// The expelling process the usual one: deletion from the `_cluster` system space.
	//
	// The autoexpel logic works on startup and reacts on the reconfiguration and the
	// `box.status` watcher event. If a new instance is joined and neither of these
	// two events occur, autoexpel does not perform any actions on it. In other words,
	// it doesn't forbid joining of an instance that met the autoexpel criterion.
	//
	// The option is allowed on the `replicaset`, `group` and `global` levels, but
	// forbidden on the `instance` level of the cluster configuration.
	Autoexpel *InstanceConfigReplicationAutoexpel `yaml:"autoexpel,omitempty"`

	// Specifies a strategy used to bootstrap a replica set. The following strategies
	// are available:
	//
	// - `auto`: a node doesn't boot if half or more of the other nodes in a replica
	// set are not connected. For example, if a replica set contains 2 or 3 nodes, a
	// node requires 2 connected instances. In the case of 4 or 5 nodes, at least 3
	// connected instances are required. Moreover, a bootstrap leader fails to boot
	// unless every connected node has chosen it as a bootstrap leader.
	// - `config`: use the specified node to bootstrap a replica set. To specify the
	// bootstrap leader, use the `<replicaset_name>.bootstrap_leader` option.
	// - `supervised`: a bootstrap leader isn't chosen automatically but should be
	// appointed using `box.ctl.make_bootstrap_leader()` on the desired node. The
	// bootstrap leader management is in the user's responsibility unless the failover
	// coordinator is in use (replication.failover = supervised).
	// - `native`: the bootstrap leader management is performed by config's code in
	// sync with the RO/RW management (the algorithm depends on replication.failover).
	// If replication.failover = supervised, then the failover coordinator manages the
	// bootstrap leader.
	//
	// This strategy is similar to `auto` from the user perspective: everything is
	// handled by tarantool (or coordinator) on its own. However, it is based on the
	// modern `supervised` strategy, which allows to overcome some limitations. -
	// `legacy` (deprecated since 2.11.0): a node requires the
	// `replication_connect_quorum` number of other nodes to be connected. This option
	// is added to keep the compatibility with the current versions of Cartridge and
	// might be removed in the future.
	BootstrapStrategy InstanceConfigReplicationBootstrapStrategy `yaml:"bootstrap_strategy,omitempty"`

	// A timeout (in seconds) a replica waits when trying to connect to a master in a
	// cluster.
	//
	// This parameter is different from replication.timeout, which a master uses to
	// disconnect a replica when the master receives no acknowledgments of heartbeat
	// messages.
	ConnectTimeout float64 `yaml:"connect_timeout,omitempty"`

	// Specifies the leader fencing mode that affects the leader election process.
	// When the parameter is set to soft or strict, the leader resigns its leadership
	// if it has less than replication.synchro_quorum of alive connections to the
	// cluster nodes. The resigning leader receives the status of a follower in the
	// current election term and becomes read-only.
	//
	// - In `soft` mode, a connection is considered dead if there are no responses for
	// 4 * `replication.timeout` seconds both on the current leader and the followers.
	// - In `strict` mode, a connection is considered dead if there are no responses
	// for 2 * `replication.timeout` seconds on the current leader and 4 *
	// `replication.timeout` seconds on the followers. This improves the chances that
	// there is only one leader at any time.
	//
	// Fencing applies to the instances that have the `replication.election_mode` set
	// to `candidate` or `manual`. To turn off leader fencing, set
	// `election_fencing_mode` to off.
	ElectionFencingMode InstanceConfigReplicationElectionFencingMode `yaml:"election_fencing_mode,omitempty"`

	// A role of a replica set node in the leader election process.
	//
	// The possible values are:
	//
	// - `off`: a node doesn't participate in the election activities.
	// - `voter`: a node can participate in the election process but can't be a
	// leader.
	// - `candidate`: a node should be able to become a leader.
	// - `manual`: allow to control which instance is the leader explicitly instead of
	// relying on automated leader election. By default, the instance acts like a
	// voter - it is read-only and may vote for other candidate instances. Once
	// `box.ctl.promote()` is called, the instance becomes a candidate and starts a
	// new election round. If the instance wins the elections, it becomes a leader but
	// won't participate in any new elections.
	ElectionMode *InstanceConfigReplicationElectionMode `yaml:"election_mode,omitempty"`

	// Specifies the timeout (in seconds) between election rounds in the leader
	// election process if the previous round ended up with a split vote.
	//
	// It is quite big, and for most of the cases, it can be lowered to 300-400 ms.
	//
	// To avoid the split vote repeat, the timeout is randomized on each node during
	// every new election, from 100% to 110% of the original timeout value. For
	// example, if the timeout is 300 ms and there are 3 nodes started the election
	// simultaneously in the same term, they can set their election timeouts to 300,
	// 310, and 320 respectively, or to 305, 302, and 324, and so on. In that way, the
	// votes will never be split because the election on different nodes won't be
	// restarted simultaneously.
	ElectionTimeout float64 `yaml:"election_timeout,omitempty"`

	// A failover mode used to take over a master role when the current master
	// instance fails. The following modes are available:
	//
	// - `off`: Leadership in a replica set is controlled using the `database.mode`
	// option. In this case, you can set the `database.mode` option to rw on all
	// instances in a replica set to make a master-master configuration.
	// - `manual`: Leadership in a replica set is controlled using the
	// `<replicaset_name>.leader` option. In this case, a master-master configuration
	// is forbidden.
	// - `election`: Automated leader election is used to control leadership in a
	// replica set.
	// - `supervised`: (Enterprise Edition only) Leadership in a replica set is
	// controlled using an external failover coordinator.
	//
	// Notes:
	//
	// In the `off` mode, the default `database.mode` is determined as follows: `rw`
	// if there is onecinstance in a replica set; `ro` if there are several instances.
	//
	// In the `manual` mode, the `database.mode` option cannot be set explicitly. The
	// leader is configured in the read-write mode, all the other instances are
	// read-only.
	//
	// In the `election` mode and the `supervised` mode, `database.mode` and
	// `<replicaset_name>.leader` shouldn't be set explicitly.
	Failover InstanceConfigReplicationFailover `yaml:"failover,omitempty"`

	// URIs of instances that constitute a replica set. These URIs are used by an
	// instance to connect to another instance as a replica.
	//
	// Alternatively, you can use iproto.advertise.peer to specify a URI used to
	// advertise the current instance to other cluster members.
	Peers []string `yaml:"peers,omitempty"`

	// The timeout (in seconds) between attempts to reconnect to a master in case of
	// connection failure. Default is box.NULL. If the option is set to box.NULL, then
	// it equals to replication_timeout.
	ReconnectTimeout *float64 `yaml:"reconnect_timeout,omitempty"`

	// By default, if a replica adds a unique key that another replica has added,
	// replication stops with the `ER_TUPLE_FOUND` error. If
	// `replication.skip_conflict` is set to `true`, such errors are ignored.
	SkipConflict bool `yaml:"skip_conflict,omitempty"`

	// The maximum delay (in seconds) between the time when data is written to the
	// master and the time when it is written to a replica.
	//
	// If a replica should remain in the synched status disregarding of the network
	// delay, set this option to a large value.
	SyncLag float64 `yaml:"sync_lag,omitempty"`

	// The timeout (in seconds) that a node waits when trying to sync with other nodes
	// in a replica set after connecting or during a configuration update. This could
	// fail indefinitely if `replication.sync_lag` is smaller than network latency, or
	// if the replica cannot keep pace with master updates. If
	// `replication.sync_timeout` expires, the replica enters `orphan` status.
	SyncTimeout *float64 `yaml:"sync_timeout,omitempty"`

	// Puts a limit on the number of transactions in the master synchronous queue.
	//
	// `replication.synchro_queue_max_size` is measured in number of bytes to be
	// written (0 means unlimited, which was the default behaviour before). This
	// option affects only the behavior of the master, and defaults to 16 megabytes.
	//
	// Now that `replication.synchro_queue_max_size` is set on the master node,
	// tarantool will discard new transactions that try to queue after the limit is
	// reached. If a transaction had to be discarded, user will get an error message
	// "The synchronous transaction queue is full".
	//
	// This limitation does not apply during the recovery process.
	SynchroQueueMaxSize int `yaml:"synchro_queue_max_size,omitempty"`

	// A number of replicas that should confirm the receipt of a synchronous
	// transaction before it can finish its commit.
	//
	// This option supports dynamic evaluation of the quorum number. For example, the
	// default value is `N / 2 + 1` where `N` is the current number of replicas
	// registered in a replica set. Once any replicas are added or removed, the
	// expression is re-evaluated automatically.
	//
	// Note that the default value (`at least 50% of the replica set size + 1`)
	// guarantees data reliability. Using a value less than the canonical one might
	// lead to unexpected results, including a split-brain.
	//
	// `replication.synchro_quorum` is not used on replicas. If the master fails, the
	// pending synchronous transactions will be kept waiting on the replicas until a
	// new master is elected.
	SynchroQuorum interface{} `yaml:"synchro_quorum,omitempty"`

	// For synchronous replication only. Specify how many seconds to wait for a
	// synchronous transaction quorum replication until it is declared failed and is
	// rolled back.
	//
	// It is not used on replicas, so if the master fails, the pending synchronous
	// transactions will be kept waiting on the replicas until a new master is
	// elected.
	SynchroTimeout float64 `yaml:"synchro_timeout,omitempty"`

	// The number of threads spawned to decode the incoming replication data.
	//
	// In most cases, one thread is enough for all incoming data. Possible values
	// range from 1 to 1000. If there are multiple replication threads, connections to
	// serve are distributed evenly between the threads.
	Threads int `yaml:"threads,omitempty"`

	// A time interval (in seconds) used by a master to send heartbeat requests to a
	// replica when there are no updates to send to this replica. For each request, a
	// replica should return a heartbeat acknowledgment.
	//
	// If a master or replica gets no heartbeat message for `4 * replication.timeout`
	// seconds, a connection is dropped and a replica tries to reconnect to the
	// master.
	Timeout float64 `yaml:"timeout,omitempty"`
}

// Automatically expel instances.
//
// The option is useful for management of dynamic clusters using the YAML
// configuration. The option allows to automatically expel instances that are
// removed from the YAML configuration.
//
// Only instances whose names start from the given prefix are taken into account,
// all the others are ignored. Also, instances without a persistent name set are
// ignored too.
//
// If an instance is in read-write mode and has a latest database schema, it
// performs expelling of the instances:
//
// - with the given prefix, *and*
// - not present in the YAML configuration.
//
// The expelling process the usual one: deletion from the `_cluster` system space.
//
// The autoexpel logic works on startup and reacts on the reconfiguration and the
// `box.status` watcher event. If a new instance is joined and neither of these two
// events occur, autoexpel does not perform any actions on it. In other words, it
// doesn't forbid joining of an instance that met the autoexpel criterion.
//
// The option is allowed on the `replicaset`, `group` and `global` levels, but
// forbidden on the `instance` level of the cluster configuration.
type InstanceConfigReplicationAutoexpel struct {
	// The autoexpel criterion: it defines how to determine that an instance is part
	// of the cluster configuration and is not an external service that uses the
	// replication channel (such as a CDC tool).
	//
	// Now, only `replication.autoexpel.by` = `prefix` criterion is supported. A user
	// have to set it explicitly.
	//
	// In future we can provide other criteria and set one of them as default.
	By *InstanceConfigReplicationAutoexpelBy `yaml:"by,omitempty"`

	// Determines, whether the autoexpelling logic is enabled at all. If the option is
	// set, `replication.autoexpel.by` and `replication.autoexpel.prefix` are
	// required.
	Enabled bool `yaml:"enabled,omitempty"`

	// Defines a pattern for instance names that are considered a part of the cluster
	// (not some external services).
	//
	// For example, if all the instances in the cluster configuration are prefixed
	// with the replica set name, one can use `replication.autoexpel.prefix` = '{{
	// replicaset_name }}'`.
	//
	// If all the instances follow the `i-\d\d\d` pattern, the option can be set to
	// `i-`.
	Prefix *string `yaml:"prefix,omitempty"`
}

type InstanceConfigReplicationAutoexpelBy string

const InstanceConfigReplicationAutoexpelByPrefix InstanceConfigReplicationAutoexpelBy = "prefix"

type InstanceConfigReplicationBootstrapStrategy string

const InstanceConfigReplicationBootstrapStrategyAuto InstanceConfigReplicationBootstrapStrategy = "auto"
const InstanceConfigReplicationBootstrapStrategyConfig InstanceConfigReplicationBootstrapStrategy = "config"
const InstanceConfigReplicationBootstrapStrategyLegacy InstanceConfigReplicationBootstrapStrategy = "legacy"
const InstanceConfigReplicationBootstrapStrategyNative InstanceConfigReplicationBootstrapStrategy = "native"
const InstanceConfigReplicationBootstrapStrategySupervised InstanceConfigReplicationBootstrapStrategy = "supervised"

type InstanceConfigReplicationElectionFencingMode string

const InstanceConfigReplicationElectionFencingModeOff InstanceConfigReplicationElectionFencingMode = "off"
const InstanceConfigReplicationElectionFencingModeSoft InstanceConfigReplicationElectionFencingMode = "soft"
const InstanceConfigReplicationElectionFencingModeStrict InstanceConfigReplicationElectionFencingMode = "strict"

type InstanceConfigReplicationElectionMode string

const InstanceConfigReplicationElectionModeCandidate InstanceConfigReplicationElectionMode = "candidate"
const InstanceConfigReplicationElectionModeManual InstanceConfigReplicationElectionMode = "manual"
const InstanceConfigReplicationElectionModeOff InstanceConfigReplicationElectionMode = "off"
const InstanceConfigReplicationElectionModeVoter InstanceConfigReplicationElectionMode = "voter"

type InstanceConfigReplicationFailover string

const InstanceConfigReplicationFailoverElection InstanceConfigReplicationFailover = "election"
const InstanceConfigReplicationFailoverManual InstanceConfigReplicationFailover = "manual"
const InstanceConfigReplicationFailoverOff InstanceConfigReplicationFailover = "off"
const InstanceConfigReplicationFailoverSupervised InstanceConfigReplicationFailover = "supervised"

// Specify a role's configuration. This option accepts a role name as the key and a
// role's configuration as the value. To specify the roles of an instance, use the
// roles option.
type InstanceConfigRolesCfg map[string]interface{}

// This section defines configuration parameters related to various security
// settings.
type InstanceConfigSecurity struct {
	// Specify a period of time (in seconds) that a specific user should wait for the
	// next attempt after failed authentication.
	//
	// The `security.auth_retries` option lets a client try to authenticate the
	// specified number of times before `security.auth_delay` is enforced.
	AuthDelay float64 `yaml:"auth_delay,omitempty"`

	// Specify the maximum number of authentication retries allowed before
	// `security.auth_delay` is enforced. The default value is 0, which means
	// `security.auth_delay` is enforced after the first failed authentication
	// attempt.
	//
	// The retry counter is reset after `security.auth_delay` seconds since the first
	// failed attempt. For example, if a client tries to authenticate fewer than
	// `security.auth_retries` times within `security.auth_delay` seconds, no
	// authentication delay is enforced. The retry counter is also reset after any
	// successful authentication attempt.
	AuthRetries int `yaml:"auth_retries,omitempty"`

	// Specify a protocol used to authenticate users. The possible values are:
	//
	// - `chap-sha1`: use the CHAP protocol with SHA-1 hashing applied to passwords.
	// - `pap-sha256`: use PAP authentication with the SHA256 hashing algorithm.
	//
	// Note that CHAP stores password hashes in the `_user` space unsalted. If an
	// attacker gains access to the database, they may crack a password, for example,
	// using a rainbow table. For PAP, a password is salted with a user-unique salt
	// before saving it in the database, which keeps the database protected from
	// cracking using a rainbow table.
	AuthType InstanceConfigSecurityAuthType `yaml:"auth_type,omitempty"`

	// If `true`, turn off access over remote connections from unauthenticated or
	// guest users. This option affects connections between cluster members and
	// `net.box` connections.
	DisableGuest bool `yaml:"disable_guest,omitempty"`

	// If true, a password should contain digits (0-9).
	PasswordEnforceDigits bool `yaml:"password_enforce_digits,omitempty"`

	// If true, a password should contain lowercase letters (a-z).
	PasswordEnforceLowercase bool `yaml:"password_enforce_lowercase,omitempty"`

	// If true, a password should contain at least one special character (such as
	// &|?!@$).
	PasswordEnforceSpecialchars bool `yaml:"password_enforce_specialchars,omitempty"`

	// If true, a password should contain uppercase letters (A-Z).
	PasswordEnforceUppercase bool `yaml:"password_enforce_uppercase,omitempty"`

	// Specify the number of unique new user passwords before an old password can be
	// reused. Note tarantool uses the auth_history field in the `box.space._user`
	// system space to store user passwords.
	PasswordHistoryLength int `yaml:"password_history_length,omitempty"`

	// Specify the maximum period of time (in days) a user can use the same password.
	// When this period ends, a user gets the "Password expired" error on a login
	// attempt. To restore access for such users, use `box.schema.user.passwd`.
	PasswordLifetimeDays int `yaml:"password_lifetime_days,omitempty"`

	// Specify the minimum number of characters for a password.
	PasswordMinLength int `yaml:"password_min_length,omitempty"`

	// If `true`, forces Tarantool to overwrite a data file a few times before
	// deletion to render recovery of a deleted file impossible. The option applies to
	// both `.xlog` and `.snap` files as well as Vinyl data files.
	SecureErasing bool `yaml:"secure_erasing,omitempty"`
}

type InstanceConfigSecurityAuthType string

const InstanceConfigSecurityAuthTypeChapSha1 InstanceConfigSecurityAuthType = "chap-sha1"
const InstanceConfigSecurityAuthTypePapSha256 InstanceConfigSecurityAuthType = "pap-sha256"

// This section defines configuration parameters related to sharding.
type InstanceConfigSharding struct {
	// The total number of buckets in a cluster.
	BucketCount int `yaml:"bucket_count,omitempty"`

	// Time to outdate old objects on reload.
	ConnectionOutdateDelay *float64 `yaml:"connection_outdate_delay,omitempty"`

	// A mode of the background discovery fiber used by the router to find buckets.
	DiscoveryMode InstanceConfigShardingDiscoveryMode `yaml:"discovery_mode,omitempty"`

	// The timeout (in seconds) after which a node is considered unavailable if there
	// are no responses during this period. The failover fiber is used to detect if a
	// node is down.
	FailoverPingTimeout float64 `yaml:"failover_ping_timeout,omitempty"`

	// Whether a replica set is locked. A locked replica set cannot receive new
	// buckets nor migrate its own buckets.
	Lock *bool `yaml:"lock,omitempty"`

	// The maximum bucket disbalance threshold (in percent). The disbalance is
	// calculated for each replica set using the following formula:
	//
	// `|etalon_bucket_count - real_bucket_count| / etalon_bucket_count * 100`
	RebalancerDisbalanceThreshold float64 `yaml:"rebalancer_disbalance_threshold,omitempty"`

	// The maximum number of buckets that can be received in parallel by a single
	// replica set. This number must be limited because the rebalancer sends a large
	// number of buckets from the existing replica sets to the newly added one. This
	// produces a heavy load on the new replica set.
	RebalancerMaxReceiving int `yaml:"rebalancer_max_receiving,omitempty"`

	// The degree of parallelism for parallel rebalancing.
	RebalancerMaxSending int `yaml:"rebalancer_max_sending,omitempty"`

	// Configure how a rebalancer is selected:
	//
	// - `auto` (default): if there are no replica sets with the rebalancer sharding
	// role (`sharding.roles`), a replica set with the rebalancer is selected
	// automatically among all replica sets.
	// - `manual`: one of the replica sets should have the rebalancer sharding role.
	// The rebalancer is in this replica set.
	// - `off`: rebalancing is turned off regardless of whether a replica set with the
	// rebalancer sharding role exists or not.
	RebalancerMode InstanceConfigShardingRebalancerMode `yaml:"rebalancer_mode,omitempty"`

	// Roles of a replica set in regard to sharding. A replica set can have the
	// following roles:
	//
	// - `router`: a replica set acts as a router.
	// - `storage`: a replica set acts as a storage.
	// - `rebalancer`: a replica set acts as a rebalancer.
	//
	// The rebalancer role is optional. If it is not specified, a rebalancer is
	// selected automatically from the master instances of replica sets.
	//
	// There can be at most one replica set with the rebalancer role. Additionally,
	// this replica set should have a `storage` role.
	Roles []InstanceConfigShardingRolesElem `yaml:"roles,omitempty"`

	// A scheduler's bucket move quota used by the rebalancer.
	//
	// `sched_move_quota` defines how many bucket moves can be done in a row if there
	// are pending storage refs. Then, bucket moves are blocked and a router continues
	// making map-reduce requests.
	SchedMoveQuota float64 `yaml:"sched_move_quota,omitempty"`

	// A scheduler's storage ref quota used by a router's map-reduce API. For example,
	// the `vshard.router.map_callrw()` function implements consistent map-reduce over
	// the entire cluster.
	//
	// `sched_ref_quota` defines how many storage refs, therefore map-reduce requests,
	// can be executed on the storage in a row if there are pending bucket moves.
	// Then, storage refs are blocked and the rebalancer continues bucket moves.
	SchedRefQuota float64 `yaml:"sched_ref_quota,omitempty"`

	// The name or ID of a TREE index over the bucket id. Spaces without this index do
	// not participate in a sharded Tarantool cluster and can be used as regular
	// spaces if needed. It is necessary to specify the first part of the index, other
	// parts are optional.
	ShardIndex string `yaml:"shard_index,omitempty"`

	// The timeout to wait for synchronization of the old master with replicas before
	// demotion. Used when switching a master or when manually calling the `sync()`
	// function.
	SyncTimeout float64 `yaml:"sync_timeout,omitempty"`

	// The relative amount of data that a replica set can store.
	Weight float64 `yaml:"weight,omitempty"`

	// A zone that can be set for routers and replicas. This allows sending read-only
	// requests not only to a master instance but to any available replica that is the
	// nearest to the router.
	Zone *int `yaml:"zone,omitempty"`
}

type InstanceConfigShardingDiscoveryMode string

const InstanceConfigShardingDiscoveryModeOff InstanceConfigShardingDiscoveryMode = "off"
const InstanceConfigShardingDiscoveryModeOn InstanceConfigShardingDiscoveryMode = "on"
const InstanceConfigShardingDiscoveryModeOnce InstanceConfigShardingDiscoveryMode = "once"

type InstanceConfigShardingRebalancerMode string

const InstanceConfigShardingRebalancerModeAuto InstanceConfigShardingRebalancerMode = "auto"
const InstanceConfigShardingRebalancerModeManual InstanceConfigShardingRebalancerMode = "manual"
const InstanceConfigShardingRebalancerModeOff InstanceConfigShardingRebalancerMode = "off"

type InstanceConfigShardingRolesElem string

const InstanceConfigShardingRolesElemRebalancer InstanceConfigShardingRolesElem = "rebalancer"
const InstanceConfigShardingRolesElemRouter InstanceConfigShardingRolesElem = "router"
const InstanceConfigShardingRolesElemStorage InstanceConfigShardingRolesElem = "storage"

// This section defines configuration parameters related to the snapshot files.
type InstanceConfigSnapshot struct {
	// An object containing configuration options that specify the conditions under
	// which automatic snapshots are created by the checkpoint daemon. This includes
	// settings like `interval` for time-based snapshots and `wal_size` for snapshots
	// triggered when the total size of WAL files exceeds a certain threshold.
	By *InstanceConfigSnapshotBy `yaml:"by,omitempty"`

	// The maximum number of snapshots that are stored in the `snapshot.dir`
	// directory. If the number of snapshots after creating a new one exceeds this
	// value, the Tarantool garbage collector deletes old snapshots. If
	// `snapshot.count` is set to zero, the garbage collector does not delete old
	// snapshots.
	Count int `yaml:"count,omitempty"`

	// A directory where memtx stores snapshot (`.snap`) files. A relative path in
	// this option is interpreted as relative to `process.work_dir`.
	//
	// By default, snapshots and WAL files are stored in the same directory. However,
	// you can set different values for the `snapshot.dir` and `wal.dir` options to
	// store them on different physical disks for performance matters.
	Dir string `yaml:"dir,omitempty"`

	// Reduce the throttling effect of `box.snapshot()` on `INSERT/UPDATE/DELETE`
	// performance by setting a limit on how many megabytes per second it can write to
	// disk. The same can be achieved by splitting `wal.dir` and `snapshot.dir`
	// locations and moving snapshots to a separate disk. The limit also affects what
	// `box.stat.vinyl().regulator` may show for the write rate of dumps to `.run` and
	// `.index` files.
	SnapIoRateLimit *float64 `yaml:"snap_io_rate_limit,omitempty"`
}

// An object containing configuration options that specify the conditions under
// which automatic snapshots are created by the checkpoint daemon. This includes
// settings like `interval` for time-based snapshots and `wal_size` for snapshots
// triggered when the total size of WAL files exceeds a certain threshold.
type InstanceConfigSnapshotBy struct {
	// The interval in seconds between actions by the checkpoint daemon. If the option
	// is set to a value greater than zero, and there is activity that causes change
	// to a database, then the checkpoint daemon calls `box.snapshot()` every
	// `snapshot.by.interval` seconds, creating a new snapshot file each time. If the
	// option is set to zero, the checkpoint daemon is disabled.
	Interval float64 `yaml:"interval,omitempty"`

	// The threshold for the total size in bytes for all WAL files created since the
	// last snapshot taken. Once the configured threshold is exceeded, the WAL thread
	// notifies the checkpoint daemon that it must make a new snapshot and delete old
	// WAL files.
	WalSize int `yaml:"wal_size,omitempty"`
}

// This section defines configuration parameters related to SQL.
type InstanceConfigSql struct {
	// The maximum cache size (in bytes) for all SQL prepared statements. To see the
	// actual cache size, use `box.info.sql().cache.size`.
	CacheSize int `yaml:"cache_size,omitempty"`
}

// This section defines configuration parameters related to the vinyl storage
// engine.
type InstanceConfigVinyl struct {
	// A bloom filter's false positive rate - the suitable probability of the bloom
	// filter to give a wrong result. The `vinyl.bloom_fpr` setting is a default value
	// for the bloom_fpr option passed to `space_object:create_index()`.
	BloomFpr float64 `yaml:"bloom_fpr,omitempty"`

	// The cache size for the vinyl storage engine. The cache can be resized
	// dynamically.
	Cache int `yaml:"cache,omitempty"`

	// Enable the deferred DELETE optimization in vinyl. It was disabled by default
	// since Tarantool version 2.10 to avoid possible performance degradation of
	// secondary index reads.
	DeferDeletes bool `yaml:"defer_deletes,omitempty"`

	// A directory where vinyl files or subdirectories will be stored. This option may
	// contain a relative file path. In this case, it is interpreted as relative to
	// `process.work_dir`.
	Dir string `yaml:"dir,omitempty"`

	// The size of the largest allocation unit, for the vinyl storage engine. It can
	// be increased if it is necessary to store large tuples.
	MaxTupleSize int `yaml:"max_tuple_size,omitempty"`

	// The maximum number of in-memory bytes that vinyl uses.
	Memory int `yaml:"memory,omitempty"`

	// The page size. A page is a read/write unit for vinyl disk operations. The
	// `vinyl.page_size` setting is a default value for the page_size option passed to
	// `space_object:create_index()`.
	PageSize int `yaml:"page_size,omitempty"`

	// The default maximum range size for a vinyl index, in bytes. The maximum range
	// size affects the decision of whether to split a range.
	//
	// If `vinyl.range_size` is specified (but the value is not null or 0), then it is
	// used as the default value for the range_size option passed to
	// `space_object:create_index()`.
	//
	// If `vinyl.range_size` is not specified (or is explicitly set to null or 0), and
	// `range_size` is not specified when the index is created, then Tarantool sets a
	// value later depending on performance considerations. To see the actual value,
	// use `index_object:stat().range_size`.
	RangeSize *int `yaml:"range_size,omitempty"`

	// The maximum number of read threads that vinyl can use for concurrent
	// operations, such as I/O and compression.
	ReadThreads int `yaml:"read_threads,omitempty"`

	// The maximum number of runs per level in the vinyl LSM tree. If this number is
	// exceeded, a new level is created. The `vinyl.run_count_per_level` setting is a
	// default value for the run_count_per_level option passed to
	// `space_object:create_index()`.
	RunCountPerLevel int `yaml:"run_count_per_level,omitempty"`

	// The ratio between the sizes of different levels in the LSM tree. The
	// `vinyl.run_size_ratio` setting is a default value for the run_size_ratio option
	// passed to `space_object:create_index()`.
	RunSizeRatio float64 `yaml:"run_size_ratio,omitempty"`

	// The vinyl storage engine has a scheduler that performs compaction. When vinyl
	// is low on available memory, the compaction scheduler may be unable to keep up
	// with incoming update requests. In that situation, queries may time out after
	// vinyl.timeout seconds. This should rarely occur, since normally vinyl throttles
	// inserts when it is running low on compaction bandwidth. Compaction can also be
	// initiated manually with `index_object:compact()`.
	Timeout float64 `yaml:"timeout,omitempty"`

	// The maximum number of write threads that vinyl can use for some concurrent
	// operations, such as I/O and compression.
	WriteThreads int `yaml:"write_threads,omitempty"`
}

// This section defines configuration parameters related to write-ahead log.
type InstanceConfigWal struct {
	// The delay in seconds used to prevent the Tarantool garbage collector from
	// immediately removing write-ahead log files after a node restart. This delay
	// eliminates possible erroneous situations when the master deletes WALs needed by
	// replicas after restart. As a consequence, replicas sync with the master faster
	// after its restart and don't need to download all the data again. Once all the
	// nodes in the replica set are up and running, a scheduled garbage collection is
	// started again even if `wal.cleanup_delay` has not expired.
	CleanupDelay *float64 `yaml:"cleanup_delay,omitempty"`

	// A directory where write-ahead log (`.xlog`) files are stored. A relative path
	// in this option is interpreted as relative to `process.work_dir`.
	//
	// By default, WAL files and snapshots are stored in the same directory. However,
	// you can set different values for the `wal.dir` and `snapshot.dir` options to
	// store them on different physical disks for performance matters.
	Dir string `yaml:"dir,omitempty"`

	// The time interval in seconds between periodic scans of the write-ahead-log file
	// directory, when checking for changes to write-ahead-log files for the sake of
	// replication or hot standby.
	DirRescanDelay float64 `yaml:"dir_rescan_delay,omitempty"`

	// This section describes options related to WAL extensions.
	Ext *InstanceConfigWalExt `yaml:"ext,omitempty"`

	// The maximum number of bytes in a single write-ahead log file. When a request
	// would cause an `.xlog` file to become larger than `wal.max_size`, Tarantool
	// creates a new WAL file.
	MaxSize int `yaml:"max_size,omitempty"`

	// Specify fiber-WAL-disk synchronization mode as:
	//
	// - `none`: write-ahead log is not maintained. A node with `wal.mode` set to
	// `none` can't be a replication master.
	// - `write`: fibers wait for their data to be written to the write-ahead log (no
	// `fsync(2)`).
	// - `fsync`: fibers wait for their data, `fsync(2)` follows each `write(2)`.
	Mode InstanceConfigWalMode `yaml:"mode,omitempty"`

	// The size of the queue in bytes used by a replica to submit new transactions to
	// a write-ahead log (WAL). This option helps limit the rate at which a replica
	// submits transactions to the WAL. Limiting the queue size might be useful when a
	// replica is trying to sync with a master and reads new transactions faster than
	// writing them to the WAL.
	QueueMaxSize int `yaml:"queue_max_size,omitempty"`

	// The delay in seconds used to prevent the Tarantool garbage collector from
	// removing a write-ahead log file after it has been closed. If a node is
	// restarted, `wal.retention_period` counts down from the last modification time
	// of the write-ahead log file.
	//
	// The garbage collector doesn't track write-ahead logs that are to be relayed to
	// anonymous replicas, such as:
	//
	// - Anonymous replicas added as a part of a cluster configuration (see
	// `replication.anon`).
	// - CDC (Change Data Capture) that retrieves data using anonymous replication.
	//
	// In case of a replica or CDC downtime, the required write-ahead logs can be
	// removed. As a result, such a replica needs to be rebootstrapped. You can use
	// wal.retention_period to prevent such issues.
	//
	// Note that `wal.cleanup_delay` option also sets the delay used to prevent the
	// Tarantool garbage collector from removing write-ahead logs. The difference is
	// that the garbage collector doesn't take into account `wal.cleanup_delay` if all
	// the nodes in the replica set are up and running, which may lead to the removal
	// of the required write-ahead logs.
	RetentionPeriod float64 `yaml:"retention_period,omitempty"`
}

// This section describes options related to WAL extensions.
type InstanceConfigWalExt struct {
	// Enable storing a new tuple for each CRUD operation performed. The option is in
	// effect for all spaces. To adjust the option for specific spaces, use the
	// `wal.ext.spaces` option.
	New *bool `yaml:"new,omitempty"`

	// Enable storing an old tuple for each CRUD operation performed. The option is in
	// effect for all spaces. To adjust the option for specific spaces, use the
	// `wal.ext.spaces` option.
	Old *bool `yaml:"old,omitempty"`

	// Enable or disable storing an old and new tuple in the WAL record for a given
	// space explicitly. The configuration for specific spaces has priority over the
	// configuration in the `wal.ext.new` and `wal.ext.old` options.
	//
	// The option is a key-value pair:
	//
	// - The key is a space name (string).
	// - The value is a table that includes two optional boolean options: `old` and
	// `new`. The format and the default value of these options are described in
	// `wal.ext.old` and `wal.ext.new`.
	Spaces InstanceConfigWalExtSpaces `yaml:"spaces,omitempty"`
}

// Enable or disable storing an old and new tuple in the WAL record for a given
// space explicitly. The configuration for specific spaces has priority over the
// configuration in the `wal.ext.new` and `wal.ext.old` options.
//
// The option is a key-value pair:
//
// - The key is a space name (string).
// - The value is a table that includes two optional boolean options: `old` and
// `new`. The format and the default value of these options are described in
// `wal.ext.old` and `wal.ext.new`.
type InstanceConfigWalExtSpaces map[string]struct {
	// Enable storing a new tuple for each CRUD operation performed. The option is in
	// effect for all spaces. To adjust the option for specific spaces, use the
	// `wal.ext.spaces` option.
	New bool `yaml:"new,omitempty"`

	// Enable storing an old tuple for each CRUD operation performed. The option is in
	// effect for all spaces. To adjust the option for specific spaces, use the
	// `wal.ext.spaces` option.
	Old bool `yaml:"old,omitempty"`
}

type InstanceConfigWalMode string

const InstanceConfigWalModeFsync InstanceConfigWalMode = "fsync"
const InstanceConfigWalModeNone InstanceConfigWalMode = "none"
const InstanceConfigWalModeWrite InstanceConfigWalMode = "write"

var defaultInstanceConfigYaml = []byte(`fiber:
  io_collect_interval: null
  too_long_threshold: 0.5
  top:
    enabled: false
  slice:
    err: 1
    warn: 0.5
  tx_user_pool_size: 768
  worker_pool_threads: 4
isolated: false
wal:
  ext: null
  queue_max_size: 16777216
  dir_rescan_delay: 2
  dir: var/lib/{{ instance_name }}
  retention_period: 0
  mode: write
  max_size: 268435456
failover:
  connect_timeout: 1
  probe_interval: 10
  renew_interval: 10
  call_timeout: 1
  stateboard:
    enabled: true
    renew_interval: 2
    keepalive_interval: 10
  lease_interval: 30
  replicasets: {}
  log:
    to: stderr
log:
  level: 5
  format: plain
  syslog:
    identity: tarantool
    server: null
    facility: local7
  modules: null
  file: var/log/{{ instance_name }}/tarantool.log
  nonblock: false
  to: stderr
  pipe: null
iproto:
  readahead: 16320
  net_msg_max: 768
  listen: null
  threads: 1
  advertise:
    peer:
      params: {}
    client: null
    sharding:
      params: {}
feedback:
  host: https://feedback.tarantool.io
  metrics_collect_interval: 60
  send_metrics: true
  metrics_limit: 1048576
  enabled: true
  crashinfo: true
  interval: 3600
roles: []
app:
  cfg: {}
console:
  socket: var/run/{{ instance_name }}/tarantool.control
  enabled: true
replication:
  peers: null
  autoexpel:
    enabled: false
  anon_ttl: 3600
  synchro_queue_max_size: 16777216
  anon: false
  connect_timeout: 30
  reconnect_timeout: null
  sync_lag: 10
  skip_conflict: false
  threads: 1
  timeout: 1
  synchro_quorum: N / 2 + 1
  bootstrap_strategy: auto
  failover: "off"
  election_timeout: 5
  election_fencing_mode: soft
  synchro_timeout: 5
  election_mode: null
  sync_timeout: null
compat:
  sql_priv: new
  binary_data_decoding: new
  wal_cleanup_delay_deprecation: old
  sql_seq_scan_default: new
  box_cfg_replication_sync_timeout: new
  box_tuple_new_vararg: new
  console_session_scope_vars: old
  json_escape_forward_slash: new
  box_space_max: new
  box_space_execute_priv: new
  fiber_channel_close_mode: new
  box_error_serialize_verbose: old
  box_error_unpack_type_and_code: old
  yaml_pretty_multiline: new
  box_consider_system_spaces_synchronous: old
  replication_synchro_timeout: old
  box_session_push_deprecation: old
  box_tuple_extension: new
  fiber_slice_default: new
  box_info_cluster_meaning: new
  c_func_iproto_multireturn: new
lua:
  memory: 2147483648
credentials:
  roles: {}
  users: {}
sql:
  cache_size: 5242880
metrics:
  labels: {}
  include: []
  exclude: []
sharding:
  rebalancer_max_receiving: 100
  weight: 1
  shard_index: bucket_id
  sync_timeout: 1
  discovery_mode: "on"
  rebalancer_mode: auto
  failover_ping_timeout: 5
  rebalancer_max_sending: 1
  bucket_count: 3000
  sched_ref_quota: 300
  rebalancer_disbalance_threshold: 1
  roles: []
  sched_move_quota: 1
snapshot:
  snap_io_rate_limit: null
  by:
    wal_size: 1000000000000000000
    interval: 3600
  count: 2
  dir: var/lib/{{ instance_name }}
security:
  password_enforce_specialchars: false
  secure_erasing: false
  password_min_length: 0
  password_enforce_lowercase: false
  password_lifetime_days: 0
  auth_type: chap-sha1
  password_enforce_digits: false
  password_history_length: 0
  auth_retries: 0
  password_enforce_uppercase: false
  auth_delay: 0
  disable_guest: false
process:
  pid_file: var/run/{{ instance_name }}/tarantool.pid
  coredump: false
  title: tarantool - {{ instance_name }}
  background: false
  username: null
  work_dir: null
  strip_core: true
audit_log:
  format: json
  syslog:
    identity: tarantool
    server: null
    facility: local7
  file: var/log/{{ instance_name }}/audit.log
  pipe: null
  filter: []
  spaces: null
  extract_key: false
  to: devnull
  nonblock: false
database:
  use_mvcc_engine: false
  instance_uuid: null
  txn_timeout: 3153600000
  txn_isolation: best-effort
  replicaset_uuid: null
  mode: null
  hot_standby: false
labels: {}
flightrec:
  logs_size: 10485760
  logs_max_msg_size: 4096
  requests_size: 10485760
  logs_log_level: 6
  requests_max_req_size: 16384
  metrics_period: 180
  metrics_interval: 1
  requests_max_res_size: 16384
  enabled: false
vinyl:
  page_size: 8192
  run_count_per_level: 2
  read_threads: 1
  write_threads: 4
  timeout: 60
  cache: 134217728
  run_size_ratio: 3.5
  max_tuple_size: 1048576
  dir: var/lib/{{ instance_name }}
  bloom_fpr: 0.05
  defer_deletes: false
  memory: 134217728
  range_size: null
roles_cfg: {}
memtx:
  sort_threads: null
  min_tuple_size: 16
  slab_alloc_factor: 1.05
  allocator: small
  max_tuple_size: 1048576
  memory: 268435456
  slab_alloc_granularity: 8
config:
  context: {}
  etcd:
    watchers: {}
    ssl: {}
    endpoints: []
    http:
      request: {}
  reload: auto
  storage:
    endpoints:
      - params: {}
    reconnect_after: 3
    timeout: 3`)
var DefaultInstanceConfig = InstanceConfig{}

func init() {
	yaml.Unmarshal(defaultInstanceConfigYaml, &DefaultInstanceConfig)
}
